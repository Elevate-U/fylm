{"version":3,"file":"Watch-CSI_urgf.js","sources":["../../src/utils/favorites.js","../../src/pages/Watch.jsx"],"sourcesContent":["import { supabase } from '../supabase';\nimport { useStore } from '../store';\nimport { route } from 'preact-router';\nimport toast from '../components/Toast';\n\n/**\n * Adds a show to the user's favorites.\n *\n * @param {object} show - The show object to add.\n * @returns {Promise<void>}\n */\nexport const addFavoriteShow = async (show) => {\n  const { data: { user } } = await supabase.auth.getUser();\n  if (!user) {\n    toast.error('You need to be logged in to save favorites.');\n    // Optionally, you could offer a button inside the toast to redirect to login\n    // For now, just showing the error is a good first step.\n    return;\n  }\n\n  const showId = show.id;\n  const { getState, setState } = useStore;\n  const state = getState();\n\n  // Prevent adding if already favorited\n  const favoriteKey = `${showId}-tv`;\n  if (state.favoritedMedia.has(favoriteKey)) {\n    return;\n  }\n\n  // Optimistic update\n  setState((currentState) => ({\n    favorites: [{ ...show, type: 'tv' }, ...currentState.favorites],\n    favoritedMedia: new Set(currentState.favoritedMedia).add(favoriteKey),\n  }));\n\n  // Show a notification\n  toast.success(`'${show.name || show.title}' has been added to your Favorites.`);\n  \n  // Add to Supabase\n  const { error } = await supabase.from('favorites').insert({\n    user_id: user.id,\n    media_id: showId,\n    media_type: 'tv',\n  });\n\n  if (error) {\n    console.error('Error adding favorite show:', error);\n    // Revert on error\n    setState((currentState) => {\n        const newFavoritedMedia = new Set(currentState.favoritedMedia);\n        newFavoritedMedia.delete(favoriteKey);\n        return {\n            favoritedMedia: newFavoritedMedia,\n            favorites: currentState.favorites.filter(f => f.id !== showId)\n        };\n    });\n  }\n};\n\n/**\n * Removes a show from the user's favorites after confirmation.\n *\n * @param {object} show - The show object to remove.\n * @returns {Promise<void>}\n */\nexport const removeFavoriteShow = async (show) => {\n  const { data: { user } } = await supabase.auth.getUser();\n  if (!user) return;\n\n  const showId = show.id;\n  const { getState, setState } = useStore;\n  const favoriteKey = `${showId}-tv`;\n\n  const originalFavorites = getState().favorites;\n  const originalFavoritedMedia = getState().favoritedMedia;\n\n  // Optimistic update\n  setState((currentState) => ({\n    favorites: currentState.favorites.filter(fav => fav.id !== showId),\n    favoritedMedia: new Set([...currentState.favoritedMedia].filter(id => id !== favoriteKey)),\n  }));\n\n  // Show a notification\n  toast.error(`'${show.name || show.title}' has been removed from your Favorites.`);\n\n  // Remove from Supabase\n  const { error } = await supabase.from('favorites').delete().match({ user_id: user.id, media_id: showId, media_type: 'tv' });\n\n  if (error) {\n      console.error('Error removing favorite show:', error);\n      // Revert on error\n      setState({ favorites: originalFavorites, favoritedMedia: originalFavoritedMedia });\n      toast.error(`Failed to remove '${show.name || show.title}' from favorites.`);\n  }\n};\n\n/**\n * Checks if a show is favorited.\n *\n * @param {number} showId - The ID of the show.\n * @returns {boolean}\n */\nexport const isShowFavorited = (showId) => {\n  return useStore.getState().favoritedMedia.has(`${showId}-tv`);\n};","import { h } from 'preact';\nimport { useState, useEffect, useRef, useMemo, useCallback } from 'preact/hooks';\nimport { route } from 'preact-router';\nimport Helmet from 'preact-helmet';\nimport { useStore } from '../store';\nimport MovieCard from '../components/MovieCard';\nimport { getWatchProgressForMedia, saveWatchProgress, getSeriesHistory, getLastWatchedEpisode, getLastWatchedEpisodeWithProgress } from '../utils/watchHistory';\nimport { useAuth } from '../context/Auth';\nimport { addFavoriteShow, removeFavoriteShow, isShowFavorited } from '../utils/favorites';\nimport './Watch.css';\nimport { API_BASE_URL, IMAGE_BASE_URL, getProxiedImageUrl } from '../config';\n\nconst Watch = (props) => {\n    const [mediaDetails, setMediaDetails] = useState(null);\n    const [videos, setVideos] = useState([]);\n    const [recommendations, setRecommendations] = useState([]);\n    const [streamUrl, setStreamUrl] = useState('');\n    const [loading, setLoading] = useState(true);\n    const [isPlaying, setIsPlaying] = useState(false);\n    const [currentSeason, setCurrentSeason] = useState(null);\n    const [currentEpisode, setCurrentEpisode] = useState(null);\n    const [currentSource, setCurrentSource] = useState('videasy');\n    const [availableSources, setAvailableSources] = useState(['videasy', 'vidsrc', 'embedsu']);\n    const [seasonDetails, setSeasonDetails] = useState(null);\n    const [episodesLoading, setEpisodesLoading] = useState(false);\n    const [isDubbed, setIsDubbed] = useState(false);\n    // Removed showNextEpisodePrompt and nextEpisodeCountdown - Videasy handles this automatically\n    const [streamError, setStreamError] = useState(null);\n    const [isRetrying, setIsRetrying] = useState(false);\n    const [streamTimeoutError, setStreamTimeoutError] = useState(false);\n    const streamTimeoutRef = useRef();\n    const [anilistId, setAnilistId] = useState(null);\n\n    const [isDirectSource, setIsDirectSource] = useState(false);\n    const [qualities, setQualities] = useState([]);\n    const videoRef = useRef(null);\n    const [seriesWatchHistory, setSeriesWatchHistory] = useState([]);\n    const [movieProgress, setMovieProgress] = useState(null);\n    const [playerReady, setPlayerReady] = useState(false);\n    const [progressToResume, setProgressToResume] = useState(0);\n    const [currentEpisodePage, setCurrentEpisodePage] = useState(1);\n    const [initialPageSet, setInitialPageSet] = useState(false);\n    const episodesPerPage = 10;\n    const sourceUpdatedFromBackend = useRef(false); // Track if source change is from backend\n    const previousEpisodeRef = useRef(null); // Track previous episode to detect navigation\n    const userNavigatedRef = useRef(false); // Track if user manually navigated to prevent auto-override\n    const hasLoadedResumeData = useRef(false); // Track if we've already loaded resume data once\n    const isAutoNavigating = useRef(false); // Track if navigation is driven by the player\n    const lastPlayerEventNavigation = useRef(null); // Track last PLAYER_EVENT navigation to prevent conflicts\n    const playerEventModeEnabled = useRef(false); // Track if PLAYER_EVENT mode is active\n    const navigationTimeouts = useRef(new Set()); // Track active navigation timeouts\n    const lastPlayerEventTime = useRef(0); // Debounce rapid PLAYER_EVENT messages\n    const lastRouteChange = useRef(0); // Debounce route changes to prevent loops\n    const routeChangeDebounceTime = 1000; // 1 second debounce for route changes\n    const ignoredLegacyNavigation = useRef(null); // Track ignored legacy navigation to prevent log spam\n    const lastHistoryUpdateRef = useRef({});\n    const lastProgressSaveRef = useRef({});\n    const lastProgressSaveTime = useRef(0); // For throttling\n    const isSavingProgressRef = useRef({}); // New ref to track in-flight requests\n\n    const { id, type, season, episode } = props.matches;\n    const { user } = useAuth(); // Get authentication state\n\n    const { setCurrentMediaItem, favoritesFetched } = useStore();\n\n    // Initialize season and episode from URL parameters immediately\n    useEffect(() => {\n        if (type === 'tv' || type === 'anime') {\n            const hasExplicitEpisode = season && episode && !isNaN(parseInt(season)) && !isNaN(parseInt(episode));\n            if (hasExplicitEpisode) {\n                const newSeason = parseInt(season, 10);\n                const newEpisode = parseInt(episode, 10);\n                setCurrentSeason(newSeason);\n                setCurrentEpisode(newEpisode);\n            } else {\n                // Default to season 1, episode 1 if no explicit values\n                setCurrentSeason(1);\n                setCurrentEpisode(1);\n            }\n        } else {\n            // For movies, set to null\n            setCurrentSeason(null);\n            setCurrentEpisode(null);\n        }\n    }, [type, season, episode]);\n\n    // Calculate movie progress percentage with a memoized hook for efficiency\n    const movieProgressPercent = useMemo(() => {\n        if (type !== 'movie' || !movieProgress || !movieProgress.progress_seconds || movieProgress.progress_seconds <= 0) {\n            return 0;\n        }\n        if (movieProgress.duration_seconds > 0) {\n            return Math.min(100, (movieProgress.progress_seconds / movieProgress.duration_seconds) * 100);\n        }\n        // Fallback for when duration is missing: 5% if over 30s, otherwise 2%\n        return movieProgress.progress_seconds > 30 ? 5 : 2;\n    }, [type, movieProgress]);\n\n    // Calculate and set initial episode page based on current episode\n    const calculateInitialEpisodePage = useCallback((targetEpisode, totalEpisodes) => {\n        if (!targetEpisode || !totalEpisodes) return 1;\n        \n        const page = Math.ceil(targetEpisode / episodesPerPage);\n        return Math.max(1, Math.min(page, Math.ceil(totalEpisodes / episodesPerPage)));\n    }, [episodesPerPage]);\n\n    // Create stable user ID reference to prevent unnecessary re-renders\n    const userId = user?.id;\n    const userIdRef = useRef(userId);\n    \n    // Update ref when userId changes but don't trigger re-renders\n    useEffect(() => {\n        userIdRef.current = userId;\n    }, [userId]);\n\n    // Helper function to debounce route changes and prevent loops\n    const debouncedRoute = (url, replace = false) => {\n        const now = Date.now();\n        if (now - lastRouteChange.current < routeChangeDebounceTime) {\n            console.log('ðŸš« Route change debounced to prevent refresh loop');\n            return;\n        }\n        lastRouteChange.current = now;\n        route(url, replace);\n    };\n\n    // Clear all navigation timeouts when component unmounts or episode changes\n    useEffect(() => {\n        return () => {\n            navigationTimeouts.current.forEach(timeout => clearTimeout(timeout));\n            navigationTimeouts.current.clear();\n        };\n    }, [currentSeason, currentEpisode]);\n\n    useEffect(() => {\n        // When the component mounts or mediaDetails changes, update the global state\n        if (mediaDetails) {\n            setCurrentMediaItem({ ...mediaDetails, type });\n        }\n        \n        // When the component unmounts, clear the global state\n        return () => {\n            setCurrentMediaItem(null);\n        };\n    }, [mediaDetails, type, setCurrentMediaItem]);\n\n    useEffect(() => {\n        if (!id || !type) {\n            route('/');\n            return;\n        }\n\n        // Reset state on new content\n        setStreamUrl('');\n        setIsDirectSource(false);\n        setQualities([]);\n        setMediaDetails(null);\n        setLoading(true);\n        // Removed prompt reset - Videasy handles this automatically\n        setSeriesWatchHistory([]);\n        // Reset navigation tracking for new content\n        userNavigatedRef.current = false;\n        hasLoadedResumeData.current = false;\n        isAutoNavigating.current = false;\n        lastPlayerEventNavigation.current = null;\n        playerEventModeEnabled.current = false;\n        // Reset pagination state for new content\n        setCurrentEpisodePage(1);\n        setInitialPageSet(false);\n        // Clear any pending navigation timeouts\n        navigationTimeouts.current.forEach(timeout => clearTimeout(timeout));\n        navigationTimeouts.current.clear();\n        // Reset debounce timer\n        lastPlayerEventTime.current = 0;\n        // Reset ignored navigation log\n        ignoredLegacyNavigation.current = null;\n\n        const fetchAllData = async () => {\n            setLoading(true);\n            try {\n                // Create abort controller for timeout handling\n                const controller = new AbortController();\n                const timeoutId = setTimeout(() => controller.abort(), 15000); // 15 second timeout\n                \n                // Fetch data with better error handling\n                const [detailsData, videosData, recommendationsData] = await Promise.all([\n                    fetch(`${API_BASE_URL}/tmdb/${type}/${id}`, { signal: controller.signal })\n                        .then(res => {\n                            if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);\n                            return res.json();\n                        })\n                        .catch(err => {\n                            console.error('Error fetching media details:', err);\n                            throw err;\n                        }),\n                    fetch(`${API_BASE_URL}/tmdb/${type}/${id}/videos`, { signal: controller.signal })\n                        .then(res => {\n                            if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);\n                            return res.json();\n                        })\n                        .catch(err => {\n                            console.error('Error fetching videos:', err);\n                            return { results: [] }; // Return empty array on error\n                        }),\n                    fetch(`${API_BASE_URL}/tmdb/${type}/${id}/recommendations`, { signal: controller.signal })\n                        .then(res => {\n                            if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);\n                            return res.json();\n                        })\n                        .catch(err => {\n                            console.error('Error fetching recommendations:', err);\n                            return { results: [] }; // Return empty array on error\n                        })\n                ]);\n                \n                clearTimeout(timeoutId);\n                setMediaDetails(detailsData);\n                setVideos(videosData.results || []);\n                setRecommendations(recommendationsData.results || []);\n\n                if (type === 'anime' && detailsData.id) {\n                    try {\n                        const anilistResponse = await fetch(`${API_BASE_URL}/anilist/from-tmdb/${detailsData.id}`);\n                        if (anilistResponse.ok) {\n                            const anilistData = await anilistResponse.json();\n                            if (anilistData.id) {\n                                setAnilistId(anilistData.id);\n                            }\n                        }\n                    } catch (error) {\n                        console.error('Error fetching AniList ID:', error);\n                    }\n                }\n                \n                // Season and episode initialization is now handled in a separate effect\n            } catch (error) {\n                setMediaDetails(null);\n                setVideos([]);\n                setRecommendations([]);\n            } finally {\n                setLoading(false);\n            }\n        };\n        fetchAllData();\n    }, [id, type, season, episode]); // Remove user from dependencies to prevent remount\n\n    // Separate effect to handle authentication-dependent data loading - ONLY run once to avoid overriding user selections\n    useEffect(() => {\n        const loadUserSpecificData = async () => {\n            if (!user || !mediaDetails || !id || !type) {\n                // Reset progress states when no user is authenticated\n                if (type === 'movie') {\n                    setMovieProgress(null);\n                } else if (type === 'tv' || type === 'anime') {\n                    setSeriesWatchHistory([]);\n                }\n                return;\n            }\n            \n            try {\n                // Only fetch user-specific data when user is authenticated\n                if ((type === 'tv' || type === 'anime') && mediaDetails.seasons && mediaDetails.seasons.length > 0) {\n                    const hasExplicitEpisode = season && episode && !isNaN(parseInt(season)) && !isNaN(parseInt(episode));\n                    \n                    // Modified logic: Always try to get continue watching when no explicit episode in URL\n                    if (!hasExplicitEpisode && !hasLoadedResumeData.current && currentSeason !== null && currentEpisode !== null) {\n                        console.log('ðŸŽ¬ Checking for continue watching episode...');\n                        const lastWatchedWithProgress = await getLastWatchedEpisodeWithProgress(id);\n                        if (lastWatchedWithProgress && lastWatchedWithProgress.season && lastWatchedWithProgress.episode) {\n                            console.log(`ðŸ”„ Continue watching: S${lastWatchedWithProgress.season}E${lastWatchedWithProgress.episode}`);\n                            // Use a timeout to prevent immediate re-render loops\n                            setTimeout(() => {\n                                setCurrentSeason(lastWatchedWithProgress.season);\n                                setCurrentEpisode(lastWatchedWithProgress.episode);\n                                // Update URL to reflect the continue watching episode\n                                const newUrl = `/watch/${type}/${id}/season/${lastWatchedWithProgress.season}/episode/${lastWatchedWithProgress.episode}`;\n                                route(newUrl, true);\n                            }, 100);\n                        } else {\n                            console.log('ðŸ“­ No continue watching data found, starting from beginning');\n                        }\n                        hasLoadedResumeData.current = true;\n                    }\n                }\n                \n                if (type === 'tv' || type === 'anime') {\n                    const history = await getSeriesHistory(id);\n                    setSeriesWatchHistory(history);\n                } else if (type === 'movie') {\n                    // Load movie progress data\n                    const progressData = await getWatchProgressForMedia(id, type);\n                    console.log('Movie progress data loaded:', progressData);\n                    setMovieProgress(progressData);\n                }\n            } catch (error) {\n                console.error('Error loading user-specific data:', error);\n            }\n        };\n        \n        loadUserSpecificData();\n    }, [user, mediaDetails, id, type]); // Remove season and episode from dependencies to prevent re-running when user changes selection\n\n    // Reset pagination when season changes, but respect initial page setting\n    useEffect(() => {\n        if (currentSeason !== null && !initialPageSet) {\n            setCurrentEpisodePage(1);\n        }\n    }, [currentSeason]);\n\n    // Pagination state is now completely independent\n\n    // Removed auto-navigation - pagination is now completely independent\n\n    useEffect(() => {\n        const fetchSeasonDetails = async () => {\n            if (type !== 'tv' && type !== 'anime' || !id || !currentSeason || currentSeason === null) return;\n            setEpisodesLoading(true);\n            try {\n                // Use the existing TMDB proxy route to fetch season details with timeout\n                const controller = new AbortController();\n                const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout\n                \n                const res = await fetch(`${API_BASE_URL}/tmdb/${type}/${id}/season/${currentSeason}`, {\n                    signal: controller.signal\n                });\n                clearTimeout(timeoutId);\n                \n                if (res.ok) {\n                    const data = await res.json();\n                    setSeasonDetails(data);\n                    \n                    // Calculate and set initial page based on current episode\n                    if (currentEpisode && data.episodes && !initialPageSet) {\n                        const page = Math.ceil(currentEpisode / episodesPerPage);\n                        const maxPage = Math.ceil(data.episodes.length / episodesPerPage);\n                        const initialPage = Math.max(1, Math.min(page, maxPage));\n                        setCurrentEpisodePage(initialPage);\n                        setInitialPageSet(true);\n                    }\n                } else {\n                    setSeasonDetails(null);\n                }\n            } catch (error) {\n                setSeasonDetails(null);\n            } finally {\n                setEpisodesLoading(false);\n            }\n        };\n        fetchSeasonDetails();\n    }, [id, type, currentSeason, currentEpisode, initialPageSet]);\n\n    useEffect(() => {\n        // Check if this is due to episode navigation\n        const currentEpisodeKey = `${currentSeason}-${currentEpisode}`;\n        const episodeChanged = previousEpisodeRef.current && previousEpisodeRef.current !== currentEpisodeKey;\n        previousEpisodeRef.current = currentEpisodeKey;\n\n        if (sourceUpdatedFromBackend.current && !episodeChanged) {\n            sourceUpdatedFromBackend.current = false;\n            return;\n        }\n\n        if (episodeChanged) {\n            sourceUpdatedFromBackend.current = false;\n        }\n\n        const fetchStreamUrl = async () => {\n            if (!id || !type || !mediaDetails) return;\n\n            const mediaId = type === 'anime' ? anilistId : id;\n            if (!mediaId) {\n                if (type === 'anime') console.log(\"Waiting for AniList ID...\");\n                return;\n            }\n\n            const isAnimeMovie = type === 'anime' && mediaDetails && (!mediaDetails.seasons || mediaDetails.seasons.length === 0);\n            \n            // For TV shows and anime SHOWS, wait until season and episode are set\n            if ((type === 'tv' || (type === 'anime' && !isAnimeMovie)) && (currentSeason === null || currentEpisode === null)) {\n                return;\n            }\n\n            // Removed prompt reset - Videasy handles this automatically\n            setStreamError(null);\n            setIsRetrying(false);\n\n            // Fetch progress directly to avoid race conditions and ensure URL is up-to-date\n            let existingProgress = 0;\n            if (userIdRef.current) {\n                try {\n                    const progressData = await getWatchProgressForMedia(id, type, currentSeason, currentEpisode);\n                    if (progressData && progressData.progress_seconds > 30) {\n                        existingProgress = progressData.progress_seconds;\n                        setProgressToResume(progressData.progress_seconds); // Update state for UI elements\n                    } else {\n                        setProgressToResume(0);\n                    }\n                } catch (error) {\n                    console.error('Error fetching progress for stream URL:', error);\n                    setProgressToResume(0);\n                }\n            } else {\n                setProgressToResume(0);\n            }\n\n            let url = `${API_BASE_URL}/stream-url?type=${type}&id=${mediaId}&source=${currentSource}`;\n            \n            if (type === 'tv' || (type === 'anime' && !isAnimeMovie)) {\n                url += `&season=${currentSeason}&episode=${currentEpisode}`;\n            }\n            \n            if (type === 'anime' && isDubbed) {\n                url += `&dub=true`;\n            }\n            \n            // Add Videasy-specific parameters for enhanced functionality\n            if (currentSource === 'videasy') {\n                // Add progress for resume functionality  \n                if (existingProgress > 30) {\n                    url += `&progress=${Math.floor(existingProgress)}`;\n                }\n                \n                // For TV shows and anime, enable all Videasy features\n                if (type === 'tv' || type === 'anime') {\n                    url += `&nextEpisode=true&episodeSelector=true&autoplayNextEpisode=true`;\n                }\n            }\n\n            try {\n                // Add timeout to stream URL fetch\n                const controller = new AbortController();\n                const timeoutId = setTimeout(() => controller.abort(), 20000); // 20 second timeout for streams\n                \n                const response = await fetch(url, { signal: controller.signal });\n                clearTimeout(timeoutId);\n                const streamUrlData = await response.json();\n\n                if (!response.ok) {\n                    throw new Error(streamUrlData.message || `HTTP ${response.status}`);\n                }\n\n                let finalStreamUrl = streamUrlData.url;\n\n                if (!finalStreamUrl) {\n                    throw new Error(\"The streaming service did not provide a valid URL. This content might not be available.\");\n                }\n                \n                if (streamUrlData.isDirectSource) {\n                    setStreamUrl(finalStreamUrl);\n                    setQualities(streamUrlData.qualities || []);\n                    setIsDirectSource(true);\n                } else {\n                    setStreamUrl(finalStreamUrl);\n                    setIsDirectSource(false);\n                    setQualities([]);\n                }\n\n                if (streamUrlData.currentSource && streamUrlData.currentSource !== currentSource) {\n                    sourceUpdatedFromBackend.current = true;\n                    setCurrentSource(streamUrlData.currentSource);\n                }\n\n                if (streamUrlData.availableSources) {\n                    setAvailableSources(streamUrlData.availableSources);\n                }\n\n                setStreamError(null);\n            } catch (error) {\n                let errorMessage = \"Could not load the video stream.\";\n                let canRetry = true;\n                \n                if (error.name === 'AbortError') {\n                    errorMessage = \"Stream request timed out. Please try again.\";\n                } else if (error.message.includes('unavailable')) {\n                    errorMessage = \"All streaming sources are currently unavailable. This is usually temporary.\";\n                } else if (error.message.includes('503')) {\n                    errorMessage = \"Streaming service is temporarily down. Please try again in a few minutes.\";\n                } else if (error.message.includes('404')) {\n                    errorMessage = \"This content is not available from the current source.\";\n                } else if (error.message.includes('NetworkError') || error.message.includes('fetch')) {\n                    errorMessage = \"Network connection issue. Please check your internet and try again.\";\n                } else {\n                    errorMessage = \"Unable to load video stream. This might be due to leaving and returning to the browser.\";\n                }\n                \n                setStreamError({ message: errorMessage, canRetry });\n                setStreamUrl('');\n                setIsDirectSource(false);\n            }\n        };\n\n        fetchStreamUrl();\n    }, [id, type, currentSeason, currentEpisode, currentSource, isDubbed, mediaDetails, anilistId]); // Add mediaDetails as a dependency\n\n    // Removed handleNextEpisode and countdown logic - Videasy handles episode navigation automatically\n\n    // Add immediate watch history entry when user navigates to watch page (throttled)\n    // This useEffect hook has been removed as it was causing logic conflicts.\n    // The saveWatchProgress function in the database now handles all history updates.\n    /*\n    useEffect(() => {\n        if (user && mediaDetails) {\n            const historyKey = `${id}-${type}-${currentSeason}-${currentEpisode}`;\n            const now = Date.now();\n            const lastHistoryUpdate = lastHistoryUpdateRef.current;\n            \n            if (!lastHistoryUpdate[historyKey] || now - lastHistoryUpdate[historyKey] > 5000) {\n                console.log('ðŸ“ Adding immediate watch history entry:', {\n                    mediaId: id,\n                    type,\n                    season: currentSeason,\n                    episode: currentEpisode,\n                    title: mediaDetails.title || mediaDetails.name\n                });\n                \n                addWatchHistoryEntry(\n                    { ...mediaDetails, id: mediaDetails.id, type, season: currentSeason, episode: currentEpisode }\n                ).then(() => {\n                    console.log('âœ… Watch history entry added successfully');\n                }).catch(error => {\n                    console.error('âŒ Failed to add watch history entry:', error);\n                });\n                \n                lastHistoryUpdate[historyKey] = now;\n            }\n        }\n    }, [user, mediaDetails, type, currentSeason, currentEpisode, id]);\n    */\n\n    // Progress tracking for different streaming services\n    useEffect(() => {\n        if (user) {\n            console.log('ðŸ” Progress tracking setup:', { \n                hasUser: true, \n                userId: user.id, \n                hasMediaDetails: !!mediaDetails \n            });\n        }\n        \n        if (!user || !mediaDetails) {\n            if (user && !mediaDetails) {\n                console.log('âš ï¸ Progress tracking disabled - media details not yet available');\n            }\n            return;\n        }\n\n        // This function will be called by the message event listener\n        const handleProgressUpdate = async (progressData, messageType) => {\n            console.log(`ðŸ“Š Progress update received via ${messageType}: `, progressData);\n            \n            // Determine the season and episode to save progress for.\n            // Prioritize data from the event, then fall back to component state.\n            const seasonToSave = progressData.season || currentSeason;\n            const episodeToSave = progressData.episode || currentEpisode;\n\n            if (progressData && progressData.progress >= 0 && progressData.duration > 0) {\n                const now = Date.now();\n                const progressKey = `${id}-${type}-${seasonToSave}-${episodeToSave}`;\n                const lastProgressSave = lastProgressSaveRef.current;\n                \n                // **MODIFIED LOGIC**\n                // Check if a save is already in progress for this item\n                if (isSavingProgressRef.current[progressKey]) {\n                    console.log(`â­ï¸ Progress save skipped (already in progress for ${progressKey})`);\n                    return;\n                }\n\n                if (!lastProgressSave[progressKey] || now - lastProgressSave[progressKey] > 5000) {\n                    // Set saving flag immediately\n                    isSavingProgressRef.current[progressKey] = true;\n\n                    try {\n                        console.log(`ðŸŽ¬ Attempting to save progress for ${type} ${id}:`, {\n                            progress: progressData.progress,\n                            duration: progressData.duration,\n                            season: seasonToSave,\n                            episode: episodeToSave\n                        });\n                        \n                        const saveResult = await saveWatchProgress(\n                            user?.id,\n                            { ...mediaDetails, id: mediaDetails.id, type, season: seasonToSave, episode: episodeToSave },\n                            progressData.progress,\n                            progressData.duration\n                        );\n                        \n                        if (saveResult) {\n                            console.log('âœ… Progress saved successfully');\n                            // Update the last save time *after* a successful save\n                            lastProgressSaveRef.current[progressKey] = now;\n\n                            // Update state in real-time only if the progress applies to the currently viewed item\n                            if (seasonToSave === currentSeason && episodeToSave === currentEpisode) {\n                                if (type === 'movie') {\n                                    setMovieProgress({\n                                        progress_seconds: progressData.progress,\n                                        duration_seconds: progressData.duration\n                                    });\n                                } else if (type === 'tv' || type === 'anime') {\n                                    setSeriesWatchHistory(prevHistory => {\n                                        const historyCopy = [...prevHistory];\n                                        const index = historyCopy.findIndex(\n                                            h => h.season_number === seasonToSave && h.episode_number === episodeToSave\n                                        );\n                                \n                                        const newProgressData = {\n                                            media_id: parseInt(id, 10),\n                                            media_type: type,\n                                            season_number: seasonToSave,\n                                            episode_number: episodeToSave,\n                                            progress_seconds: progressData.progress,\n                                            duration_seconds: progressData.duration,\n                                        };\n                                \n                                        if (index > -1) {\n                                            historyCopy[index] = { ...historyCopy[index], ...newProgressData };\n                                        } else {\n                                            historyCopy.push(newProgressData);\n                                        }\n                                \n                                        return historyCopy;\n                                    });\n                                }\n                            }\n                        } else {\n                            console.error('âŒ Failed to save progress');\n                        }\n                    } catch (error) {\n                        console.error('âŒ An unexpected error occurred while saving progress:', error);\n                    } finally {\n                        // Unset saving flag regardless of success or failure\n                        isSavingProgressRef.current[progressKey] = false;\n                    }\n                } else {\n                    console.log('â­ï¸ Progress save skipped (too recent):', {\n                        timeSinceLastSave: now - (lastProgressSave[progressKey] || 0),\n                        threshold: 5000\n                    });\n                }\n\n                // Removed next episode prompt logic - Videasy handles autoplay automatically\n                const timeRemaining = progressData.duration - progressData.progress;\n                // Videasy will handle next episode prompts automatically\n            } else {\n                console.log('âš ï¸ Progress update ignored (insufficient data):', {\n                    hasProgressData: !!progressData,\n                    progress: progressData?.progress,\n                    duration: progressData?.duration,\n                    meetsThreshold: progressData?.progress >= 0 && progressData?.duration > 0\n                });\n            }\n        };\n\n        let progressHandler;\n        let messageListener;\n\n        if (isDirectSource) {\n            // Handle direct video sources (like MP4 files)\n            const videoElement = videoRef.current;\n            if (!videoElement) return;\n\n            const handleLoadedMetadata = async () => {\n                const history = await getWatchProgressForMedia(id, type, currentSeason, currentEpisode);\n                if (history && history.progress_seconds) {\n                    videoElement.currentTime = history.progress_seconds;\n                }\n            };\n\n            const handleTimeUpdate = async () => {\n                if (videoElement.currentTime > 0) {\n                    const now = Date.now();\n                    const progressKey = `${id}-${type}-${currentSeason}-${currentEpisode}`;\n                    const lastProgressSave = lastProgressSaveRef.current;\n                    \n                    if (!lastProgressSave[progressKey] || now - lastProgressSave[progressKey] > 5000) {\n                        const progressData = {\n                            progress: Math.round(videoElement.currentTime),\n                            duration: Math.round(videoElement.duration),\n                            percentage: videoElement.duration > 0 ? (videoElement.currentTime / videoElement.duration) * 100 : 0\n                        };\n                        \n                        console.log(`ðŸŽ¬ Direct video - saving progress:`, progressData);\n                        \n                        const saveResult = await saveWatchProgress(\n                            user?.id,\n                            { ...mediaDetails, id: mediaDetails.id, type, season: currentSeason, episode: currentEpisode },\n                            progressData.progress,\n                            progressData.duration\n                        );\n                        \n                        if (saveResult) {\n                            console.log('âœ… Direct video progress saved successfully');\n                            lastProgressSave[progressKey] = now;\n\n                            // Update state in real-time\n                            if (type === 'movie') {\n                                setMovieProgress({\n                                    progress_seconds: progressData.progress,\n                                    duration_seconds: progressData.duration\n                                });\n                            } else if (type === 'tv' || type === 'anime') {\n                                setSeriesWatchHistory(prevHistory => {\n                                    const historyCopy = [...prevHistory];\n                                    const index = historyCopy.findIndex(\n                                        h => h.season_number === currentSeason && h.episode_number === currentEpisode\n                                    );\n                            \n                                    const newProgressData = {\n                                        media_id: parseInt(id, 10),\n                                        media_type: type,\n                                        season_number: currentSeason,\n                                        episode_number: currentEpisode,\n                                        progress_seconds: progressData.progress,\n                                        duration_seconds: progressData.duration,\n                                    };\n                            \n                                    if (index > -1) {\n                                        historyCopy[index] = { ...historyCopy[index], ...newProgressData };\n                                    } else {\n                                        historyCopy.push(newProgressData);\n                                    }\n                            \n                                    return historyCopy;\n                                });\n                            }\n                        } else {\n                            console.error('âŒ Failed to save direct video progress');\n                        }\n\n                        // Removed next episode prompt logic - Videasy handles autoplay automatically\n                        const timeRemaining = progressData.duration - progressData.progress;\n                        // Videasy will handle next episode prompts automatically\n                    }\n                }\n            };\n\n            videoElement.addEventListener('loadedmetadata', handleLoadedMetadata);\n            videoElement.addEventListener('timeupdate', handleTimeUpdate);\n\n            return () => {\n                videoElement.removeEventListener('loadedmetadata', handleLoadedMetadata);\n                videoElement.removeEventListener('timeupdate', handleTimeUpdate);\n            };\n        } else {\n            messageListener = (event) => {\n                const trustedDomains = ['player.videasy.net', 'vidsrc.to', 'embed.su', 'vidsrc.xyz', 'vidsrc.in', 'vidsrc.pm'];\n                const origin = new URL(event.origin);\n                \n                if (!trustedDomains.includes(origin.hostname)) {\n                    return;\n                }\n\n                try {\n                    // Attempt to parse the data if it's a string, otherwise use it directly\n                    const data = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;\n\n                    // New: Efficient `PROGRESS_UPDATE` format from Videasy/other players\n                    if (data && data.type === 'PROGRESS_UPDATE' && data.data) {\n                        const progressData = {\n                            progress: data.data.progress?.watched,\n                            duration: data.data.progress?.duration,\n                            // Ensure season/episode from the message are used if available\n                            season: data.data.season || currentSeason,\n                            episode: data.data.episode || currentEpisode\n                        };\n                        handleProgressUpdate(progressData, 'PROGRESS_UPDATE');\n                        return; // Exit after handling\n                    }\n\n                    // Deprecated: Legacy `MEDIA_DATA` format for backward compatibility\n                    if (data.type === 'MEDIA_DATA' && data.data) {\n                    \n                        let mediaData = data.data;\n                        if (typeof mediaData === 'string') {\n                            try {\n                                mediaData = JSON.parse(mediaData);\n                            } catch (e) {\n                                console.error('Error parsing double-encoded MEDIA_DATA string:', e);\n                                return;\n                            }\n                        }\n\n                        // The data can be an object keyed by `tv-id`.\n                        const mediaKey = `${type}-${id}`;\n                        const media = mediaData[mediaKey];\n                        \n                        if (media && media.progress) {\n                            const normalizedProgress = {\n                                progress: media.progress.watched,\n                                duration: media.progress.duration,\n                                season: media.last_season_watched,\n                                episode: media.last_episode_watched,\n                            };\n                            handleProgressUpdate(normalizedProgress, 'MEDIA_DATA');\n                        }\n                        return; // Exit after handling\n                    }\n\n                    // Generic event handling for other player messages\n                    if (data.type === 'PLAYER_EVENT' && data.data) {\n                        if (data.data.event === 'timeupdate') {\n                            const progressData = {\n                                progress: data.data.time,\n                                duration: data.data.duration\n                            };\n                            if (progressData.progress && progressData.duration) {\n                                handleProgressUpdate(progressData, 'PLAYER_EVENT');\n                            }\n                        } else if (data.data.event === 'ended' && (type === 'tv' || type === 'anime')) {\n                            console.log('Player reported \"ended\" event - Videasy will handle next episode automatically.');\n                            // Removed handleNextEpisode() - Videasy handles this automatically\n                        } else if (data.data.event === 'player_ready') {\n                            console.log('Player is ready.');\n                            setPlayerReady(true);\n                        }\n                    }\n\n                } catch (error) {\n                    // This will catch JSON parsing errors or other exceptions\n                    console.error(\"Error processing message from player:\", {\n                        origin: event.origin,\n                        data: event.data,\n                        error: error.message\n                    });\n                }\n            };\n            \n            window.addEventListener('message', messageListener);\n            \n            // Fallback for players that don't send `player_ready` has been moved\n            // to a dedicated useEffect hook that depends on streamUrl.\n\n            return () => {\n                window.removeEventListener('message', messageListener);\n                if (progressHandler) clearInterval(progressHandler);\n            };\n        }\n    }, [user, mediaDetails, isDirectSource, videoRef, currentSeason, currentEpisode]);\n\n    // This effect specifically handles the player ready timeout logic.\n    // It only runs when a stream URL for an iframe is present.\n    useEffect(() => {\n        if (streamUrl && !isDirectSource && !playerReady) {\n            const readyTimeout = setTimeout(() => {\n                // Re-check playerReady state inside timeout to avoid race conditions\n                if (!playerReady) {\n                    console.warn('Player ready timeout, starting fallback progress tracking.');\n                    startFallbackTracking();\n                }\n            }, 10000); // Increased timeout to 10 seconds for better reliability\n\n            return () => clearTimeout(readyTimeout);\n        }\n    }, [streamUrl, isDirectSource, playerReady]);\n\n    const startFallbackTracking = () => {\n        // Fallback progress tracking if player doesn't post messages\n        // This is a failsafe and should ideally not be relied upon\n        const progressHandler = setInterval(() => {\n            if (document.hasFocus()) {\n                console.log('Fallback: Checking for progress...');\n                // You would need a way to get progress from the iframe if possible,\n                // but cross-origin restrictions make this very difficult.\n                // This is a placeholder for a potential future implementation.\n            }\n        }, 15000);\n\n        return () => clearInterval(progressHandler);\n    };\n\n    useEffect(() => {\n        // Reset timeout error when streamUrl or error changes\n        setStreamTimeoutError(false);\n        if (!streamUrl && !streamError) {\n            streamTimeoutRef.current = setTimeout(() => {\n                setStreamTimeoutError(true);\n                console.log('Stream timeout error');\n            }, 25000); // 25 seconds\n        }\n        return () => {\n            if (streamTimeoutRef.current) clearTimeout(streamTimeoutRef.current);\n        };\n    }, [streamUrl, streamError, currentSeason, currentEpisode, currentSource]);\n\n    // Auto Picture-in-Picture on tab change\n    useEffect(() => {\n        const handleVisibilityChange = async () => {\n            if (!document.pictureInPictureEnabled) {\n                return; // PiP not supported\n            }\n\n            const videoElement = videoRef.current;\n\n            if (document.visibilityState === 'hidden') {\n                if (isDirectSource && videoElement && !videoElement.paused) {\n                    if (document.pictureInPictureElement !== videoElement) {\n                        try {\n                            await videoElement.requestPictureInPicture();\n                        } catch (error) {\n                            console.error('Failed to enter PiP mode for direct video:', error);\n                        }\n                    }\n                } else if (!isDirectSource && streamUrl) {\n                    const iframe = document.querySelector('iframe');\n                    if (iframe && iframe.contentWindow) {\n                        // This is a speculative attempt to ask the iframe to enter PiP.\n                        // The player inside the iframe must be programmed to handle this message.\n                        iframe.contentWindow.postMessage({ type: 'REQUEST_PIP' }, '*');\n                        console.log('Attempted to request Picture-in-Picture from iframe.');\n                    }\n                }\n            } else if (document.visibilityState === 'visible') {\n                // By not exiting PiP automatically, we give the user control.\n                // The user can keep the video in PiP even when returning to the tab.\n                /*\n                if (document.pictureInPictureElement) {\n                    if (isDirectSource && videoElement && document.pictureInPictureElement === videoElement) {\n                         try {\n                            await document.exitPictureInPicture();\n                        } catch (error) {\n                            console.error('Failed to exit PiP mode:', error);\n                        }\n                    }\n                    // For iframes, we don't automatically exit PiP,\n                    // as the user might want to keep it while navigating the main page.\n                    // The PiP window has its own close button.\n                }\n                */\n            }\n        };\n\n        document.addEventListener('visibilitychange', handleVisibilityChange);\n\n        return () => {\n            document.removeEventListener('visibilitychange', handleVisibilityChange);\n            // Also, if the component unmounts and we are in PiP, we should exit.\n            // Do not exit PiP on unmount to allow for navigation\n            // if (isDirectSource && videoRef.current && document.pictureInPictureElement === videoRef.current) {\n            //     document.exitPictureInPicture().catch(e => console.error(\"Could not exit PiP on unmount\", e));\n            // }\n        };\n    }, [isDirectSource, streamUrl]);\n\n    if (loading) {\n        return (\n            <div class=\"loading-state\">\n                <div class=\"loading-spinner\"></div>\n                <p>Loading media details...</p>\n                <p>If your video doesnt load refresh the page or pick a new server.</p>\n                \n            </div>\n        );\n    }\n\n    if (!mediaDetails) {\n        return (\n            <div class=\"container\">\n                <div class=\"error-state\">\n                    <h2>Unable to Load Media</h2>\n                    <p>We couldn't load the details for this content. This could be due to:</p>\n                    <ul>\n                        <li>Network connectivity issues</li>\n                        <li>The content may no longer be available</li>\n                        <li>Server maintenance</li>\n                    </ul>\n                    <button \n                        onClick={() => window.location.reload()} \n                        class=\"btn btn-primary\"\n                        style={{ marginTop: '20px' }}\n                    >\n                        Try Again\n                    </button>\n                </div>\n            </div>\n        );\n    }\n    \n    const { title, name, overview, vote_average, release_date, first_air_date, last_air_date, runtime, number_of_seasons, genres, poster_path, status } = mediaDetails;\n    \n    // For TV episodes, check if this specific episode is favorited\n    const favorited = isShowFavorited(mediaDetails.id);\n    \n    const year = release_date || first_air_date ? new Date(release_date || first_air_date).getFullYear() : '';\n\n    const handleFavoriteClick = () => {\n        if (favorited) {\n            removeFavoriteShow(mediaDetails);\n        } else {\n            addFavoriteShow({ ...mediaDetails, type });\n        }\n    };\n\n    return (\n        <div>\n            <Helmet>\n                <title>{title || name} - Fovi</title>\n            </Helmet>\n            <div class=\"player-container\">\n                {!streamUrl && streamError && (\n                    <div class=\"stream-error-message\">\n                        <p>{streamError.message}</p>\n                        {streamError.canRetry && (\n                            <div class=\"error-actions\">\n                                <button \n                                    onClick={async () => {\n                                        setIsRetrying(true);\n                                        // Wait a bit then retry\n                                        setTimeout(() => {\n                                            const fetchStreamUrl = async () => {\n                                                const url = `${API_BASE_URL}/stream-url?type=${type}&id=${id}&source=${currentSource}${(type === 'tv' || type === 'anime') ? `&season=${currentSeason}&episode=${currentEpisode}` : ''}${type === 'anime' ? `&dub=${isDubbed}` : ''}`;\n                                                \n                                                try {\n                                                    const response = await fetch(url);\n                                                    const streamUrlData = await response.json();\n                                                    \n                                                    if (response.ok) {\n                                                        setStreamUrl(streamUrlData.url);\n                                                        setIsDirectSource(streamUrlData.isDirectSource);\n                                                        setQualities(streamUrlData.qualities || []);\n                                                        setStreamError(null);\n                                                    } else {\n                                                        throw new Error(streamUrlData.message);\n                                                    }\n                                                } catch (error) {\n                                                    console.error('Retry failed:', error);\n                                                    setStreamError({ \n                                                        message: \"Retry failed. Please try selecting a different source.\", \n                                                        canRetry: true \n                                                    });\n                                                }\n                                                setIsRetrying(false);\n                                            };\n                                            fetchStreamUrl();\n                                        }, 1000);\n                                    }}\n                                    disabled={isRetrying}\n                                    class=\"btn retry-btn\"\n                                >\n                                    {isRetrying ? 'Retrying...' : 'Retry'}\n                                </button>\n                                <p>Or try selecting a different source from the list below.</p>\n                            </div>\n                        )}\n                    </div>\n                )}\n                {!streamUrl && !streamError && !streamTimeoutError && (\n                    <div class=\"stream-loading\">\n                        <p>Loading video stream... </p>\n                        <p>If your video doesnt load refresh the page or pick a new server.</p>\n                    </div>\n                )}\n                {/* PATCH: Show error if stream never loads */}\n                {!streamUrl && !streamError && streamTimeoutError && (\n                    <div class=\"stream-error-message\">\n                        <p>Sorry, this episode failed to load. Please refresh the page.</p>\n                        <div class=\"error-actions\">\n                            <button \n                                onClick={() => window.location.reload()} \n                                class=\"btn retry-btn\"\n                            >\n                                Refresh\n                            </button>\n                            <p>Or try selecting a different source from the list below if refreshing doesn't work.</p>\n                        </div>\n                    </div>\n                )}\n                {isDirectSource ? (\n                    <video ref={videoRef} src={streamUrl} controls autoPlay width=\"100%\"></video>\n                ) : (\n                    streamUrl && (\n                        <iframe \n                            src={streamUrl}\n                            width=\"100%\"\n                            height=\"100%\"\n                            style={{ position: 'absolute', top: 0, left: 0, width: '100%', height: '100%' }}\n                            frameBorder=\"0\"\n                            allowFullScreen\n                            allow=\"autoplay; picture-in-picture\"\n                            sandbox=\"allow-forms allow-pointer-lock allow-same-origin allow-scripts allow-top-navigation\"\n                            title=\"Video Player\"\n                            loading=\"eager\"\n                            referrerPolicy=\"no-referrer-when-downgrade\"\n                            importance=\"high\"\n                            onLoad={() => {\n                                console.log('ðŸŽ¬ Player iframe loaded');\n                                setPlayerReady(true);\n                                \n                                // Handle progress restoration via postMessage (only for non-Videasy sources)\n                                // Videasy handles progress natively via URL parameters for faster loading\n                                if (currentSource !== 'videasy' && progressToResume > 30) {\n                                    setTimeout(() => {\n                                        const iframe = document.querySelector('iframe');\n                                        if (iframe && iframe.contentWindow) {\n                                            try {\n                                                iframe.contentWindow.postMessage({\n                                                    type: 'SEEK_TO',\n                                                    time: progressToResume\n                                                }, '*');\n                                                console.log(`ðŸ“ Sent seek command to restore progress: ${progressToResume}s`);\n                                            } catch (e) {\n                                                console.log('Could not send seek command:', e);\n                                            }\n                                        }\n                                    }, 500); // Reduced to 500ms for faster response\n                                } else if (currentSource === 'videasy') {\n                                    console.log('ðŸ“ Videasy native resume - no seeking needed');\n                                } else {\n                                    console.log('ðŸ“ No significant progress to resume, starting from beginning');\n                                }\n                            }}\n                        ></iframe>\n                    )\n                )}\n                {/* Removed next episode prompt UI - Videasy handles this automatically */}\n            </div>\n            <div class=\"container\">\n                <div class=\"media-details-layout\">\n                    <div class=\"poster\">\n                        <img src={getProxiedImageUrl(poster_path ? `${IMAGE_BASE_URL}${poster_path}` : 'https://via.placeholder.com/500x750.png?text=No+Image')} alt={title || name} />\n                        {movieProgressPercent > 0 && (\n                            <div class=\"movie-progress-container\">\n                                <div class=\"movie-progress-bar\">\n                                    <div \n                                        class=\"movie-progress\" \n                                        style={{ width: `${Math.max(2, movieProgressPercent)}%` }}\n                                    ></div>\n                                </div>\n                                <div class=\"movie-progress-text\">\n                                    {movieProgress.duration_seconds > 0 \n                                        ? `${Math.floor(movieProgress.progress_seconds / 60)}m / ${Math.floor(movieProgress.duration_seconds / 60)}m watched`\n                                        : `${Math.floor(movieProgress.progress_seconds / 60)}m watched`\n                                    }\n                                </div>\n                            </div>\n                        )}\n                    </div>\n                                            <div class=\"details\">\n                        <div class=\"title-container\">\n                            <h1>{title || name}</h1>\n                            <button\n                                onClick={handleFavoriteClick}\n                                class={`favorite-btn ${favorited ? 'favorited' : ''}`}\n                                disabled={!favoritesFetched}\n                            >\n                                {favoritesFetched ? (favorited ? 'â™¥ Favorited' : 'â™¡ Favorite') : '...'}\n                            </button>\n                            {!user && (\n                                <span class=\"login-hint\">\n                                    <small>\n                                        <a href=\"/login\" style={{ color: '#007bff', textDecoration: 'none' }}>\n                                            Log in\n                                        </a> to save favorites, track progress & continue watching\n                                    </small>\n                                </span>\n                            )}\n                        </div>\n                        <div class=\"meta\">\n                            <span class=\"rating\">â˜… {mediaDetails.vote_average ? mediaDetails.vote_average.toFixed(1) : 'N/A'}</span>\n                            {(type === 'tv' || type === 'anime') && first_air_date && (\n                                <span style={{ marginLeft: 8 }}>\n                                    {(() => {\n                                        const startYear = first_air_date ? new Date(first_air_date).getFullYear() : null;\n                                        let endYear = null;\n                                        if (last_air_date) {\n                                            endYear = new Date(last_air_date).getFullYear();\n                                        } else if (status && status.toLowerCase() === 'ended') {\n                                            endYear = startYear;\n                                        }\n                                        if (startYear && endYear && startYear === endYear) {\n                                            return `${startYear}`;\n                                        } else if (startYear && endYear && endYear !== startYear) {\n                                            return `${startYear} - ${endYear}`;\n                                        } else if (startYear) {\n                                            return `${startYear} -`;\n                                        }\n                                        return '';\n                                    })()}\n                                </span>\n                            )}\n                            \n                            {runtime && <span>{runtime} min</span>}\n                            {number_of_seasons && <span>{number_of_seasons} Seasons</span>}\n                        </div>\n                        <div class=\"genres\">\n                            {genres && genres.map(g => <span class=\"genre-tag\">{g.name}</span>)}\n                        </div>\n                        <p class=\"overview\">{overview}</p>\n                        {qualities.length > 0 && (\n                            <div class=\"quality-selector\">\n                                <label>Quality:</label>\n                                {qualities.map(q => (\n                                    <button \n                                        class={`quality-btn ${streamUrl === q.url ? 'active' : ''}`}\n                                        onClick={() => setStreamUrl(q.url)}\n                                    >\n                                        {q.quality}p\n                                    </button>\n                                ))}\n                            </div>\n                        )}\n                    </div>\n                </div>\n                \n                {type === 'anime' && (\n                    <div class=\"select-container\">\n                        <label for=\"dub-select\">Audio:</label>\n                        <select\n                            id=\"dub-select\"\n                            value={isDubbed}\n                            onChange={(e) => setIsDubbed(e.target.value === 'true')}\n                        >\n                            <option value=\"false\">Subbed</option>\n                            <option value=\"true\">Dubbed</option>\n                        </select>\n                    </div>\n                )}\n\n                <div class=\"selectors-container\">\n                    {(type === 'tv' || type === 'anime') && mediaDetails && mediaDetails.seasons && (\n                        <div class=\"select-container\">\n                            <label>Season:</label>\n                            <div class=\"selector-buttons\">\n                                {mediaDetails.seasons\n                                    .filter(s => s.season_number > 0)\n                                    .map(s => (\n                                        <button\n                                            key={s.id}\n                                            class={`selector-btn ${currentSeason === s.season_number ? 'active' : ''}`}\n                                            onClick={() => {\n                                                console.log(`ðŸŽ¯ User manually selected season ${s.season_number}`);\n                                                userNavigatedRef.current = true;\n                                                ignoredLegacyNavigation.current = null; // Reset ignored navigation log\n                                                const newUrl = `/watch/${type}/${id}/season/${s.season_number}/episode/1`;\n                                                route(newUrl, true);\n                                            }}\n                                        >\n                                            {s.name}\n                                        </button>\n                                    ))}\n                            </div>\n                        </div>\n                    )}\n                    {availableSources.length > 1 && (\n                         <div class=\"select-container\">\n                            <label>Source:</label>\n                            <div class=\"selector-buttons\">\n                                {availableSources.map(source => (\n                                    <button\n                                        key={source}\n                                        class={`selector-btn ${currentSource === source ? 'active' : ''}`}\n                                        onClick={() => setCurrentSource(source)}\n                                    >\n                                        {source}\n                                    </button>\n                                ))}\n                            </div>\n                        </div>\n                    )}\n                </div>\n\n                {(type === 'tv' || type === 'anime') && currentSeason !== null && currentEpisode !== null && (\n                    <div class=\"episodes-container\">\n                        <h3>Episodes</h3>\n                        {episodesLoading ? (\n                            <div class=\"loading-spinner\"></div>\n                        ) : (\n                            <>\n                                <div class=\"episode-list\">\n                                    {seasonDetails?.episodes\n                                        ?.slice((currentEpisodePage - 1) * episodesPerPage, currentEpisodePage * episodesPerPage)\n                                        ?.map(episode => {\n                                            // Find the progress for this specific episode from the array\n                                            const episodeHistory = seriesWatchHistory.find(\n                                                h => h.season_number === currentSeason && h.episode_number === episode.episode_number\n                                            );\n                                            \n                                            // Calculate progress percentage with better error handling and fallback\n                                            const progressPercent = (() => {\n                                                if (episodeHistory && episodeHistory.progress_seconds > 0) {\n                                                    if (episodeHistory.duration_seconds && episodeHistory.duration_seconds > 0) {\n                                                        return Math.min(100, (episodeHistory.progress_seconds / episodeHistory.duration_seconds) * 100);\n                                                    }\n                                                    // Fallback for when duration is not available.\n                                                    // Show 5% for >30s, otherwise 2% to indicate some progress.\n                                                    return episodeHistory.progress_seconds > 30 ? 5 : 2;\n                                                }\n                                                return 0;\n                                            })();\n\n                                            return (\n                                                <div \n                                                    key={episode.id}\n                                                    class={`episode-card ${episode.episode_number === currentEpisode ? 'active' : ''}`}\n                                                    onClick={() => {\n                                                        console.log(`ðŸŽ¯ User manually selected episode ${episode.episode_number}`);\n                                                        userNavigatedRef.current = true;\n                                                        ignoredLegacyNavigation.current = null; // Reset ignored navigation log\n                                                        const newUrl = `/watch/${type}/${id}/season/${currentSeason}/episode/${episode.episode_number}`;\n                                                        route(newUrl, true);\n                                                    }}\n                                                >\n                                                    <div class=\"episode-card-image\">\n                                                        <img src={getProxiedImageUrl(episode.still_path ? `${IMAGE_BASE_URL}${episode.still_path}` : `https://via.placeholder.com/300x169.png?text=${encodeURIComponent(episode.name)}`)} alt={episode.name} />\n                                                        <div class=\"episode-number-badge\">{episode.episode_number}</div>\n                                                        {progressPercent > 0 && (\n                                                            <div class=\"episode-progress-bar\">\n                                                                <div class=\"episode-progress\" style={{width: `${Math.max(2, progressPercent)}%`}}></div>\n                                                            </div>\n                                                        )}\n                                                    </div>\n                                                    <div class=\"episode-card-content\">\n                                                        <h4>\n                                                            {episode.name}\n                                                            {episode.air_date && (\n                                                                <span style={{ color: '#aaa', fontWeight: 400, fontSize: '0.95em', marginLeft: 8 }}>\n                                                                    {'â€¢ '}\n                                                                    {(() => {\n                                                                        const d = new Date(episode.air_date);\n                                                                        if (!isNaN(d)) {\n                                                                            return d.toLocaleDateString(undefined, { month: 'short', day: 'numeric', year: 'numeric' });\n                                                                        }\n                                                                        return null;\n                                                                    })()}\n                                                                </span>\n                                                            )}\n                                                        </h4>\n                                                        <p class=\"episode-overview\">{episode.overview}</p>\n                                                    </div>\n                                                </div>\n                                            );\n                                        })}\n                                </div>\n\n                                {/* Pagination Controls */}\n                                {seasonDetails?.episodes && seasonDetails.episodes.length > episodesPerPage && (\n                                    <div class=\"pagination-controls\">\n                                        <button \n                                            class=\"pagination-btn\" \n                                            onClick={() => setCurrentEpisodePage(prev => Math.max(1, prev - 1))}\n                                            disabled={currentEpisodePage === 1}\n                                        >\n                                            â† Previous\n                                        </button>\n                                        \n                                        <div class=\"pagination-info\">\n                                            <span class=\"page-numbers\">\n                                                {Array.from({ length: Math.ceil(seasonDetails.episodes.length / episodesPerPage) }, (_, i) => i + 1).map(pageNum => (\n                                                    <button\n                                                        key={pageNum}\n                                                        class={`page-number ${pageNum === currentEpisodePage ? 'active' : ''}`}\n                                                        onClick={() => setCurrentEpisodePage(pageNum)}\n                                                    >\n                                                        {pageNum}\n                                                    </button>\n                                                ))}\n                                            </span>\n                                            <span class=\"page-text\">\n                                                Page {currentEpisodePage} of {Math.ceil(seasonDetails.episodes.length / episodesPerPage)} \n                                                ({seasonDetails.episodes.length} episodes)\n                                            </span>\n                                        </div>\n                                        \n                                        <button \n                                            class=\"pagination-btn\" \n                                            onClick={() => setCurrentEpisodePage(prev => Math.min(Math.ceil(seasonDetails.episodes.length / episodesPerPage), prev + 1))}\n                                            disabled={currentEpisodePage === Math.ceil(seasonDetails.episodes.length / episodesPerPage)}\n                                        >\n                                            Next â†’\n                                        </button>\n                                    </div>\n                                )}\n                            </>\n                        )}\n                    </div>\n                )}\n\n                {recommendations.length > 0 && (\n                    <div class=\"recommendations\">\n                        <h2>More Like This</h2>\n                        <div class=\"movie-grid\">\n                            {recommendations.map(item => (\n                                <MovieCard \n                                    key={`${item.media_type || type}-${item.id}`}\n                                    item={item} \n                                    type={type} \n                                    progress={null}\n                                    duration={null}\n                                />\n                            ))}\n                        </div>\n                    </div>\n                )}\n            </div>\n        </div>\n    );\n};\n\nexport default Watch; "],"names":["addFavoriteShow","show","user","supabase","toast","showId","getState","setState","useStore","state","favoriteKey","currentState","error","newFavoritedMedia","f","removeFavoriteShow","originalFavorites","originalFavoritedMedia","fav","id","isShowFavorited","Watch","props","mediaDetails","setMediaDetails","useState","videos","setVideos","recommendations","setRecommendations","streamUrl","setStreamUrl","loading","setLoading","isPlaying","setIsPlaying","currentSeason","setCurrentSeason","currentEpisode","setCurrentEpisode","currentSource","setCurrentSource","availableSources","setAvailableSources","seasonDetails","setSeasonDetails","episodesLoading","setEpisodesLoading","isDubbed","setIsDubbed","streamError","setStreamError","isRetrying","setIsRetrying","streamTimeoutError","setStreamTimeoutError","streamTimeoutRef","useRef","anilistId","setAnilistId","isDirectSource","setIsDirectSource","qualities","setQualities","videoRef","seriesWatchHistory","setSeriesWatchHistory","movieProgress","setMovieProgress","playerReady","setPlayerReady","progressToResume","setProgressToResume","currentEpisodePage","setCurrentEpisodePage","initialPageSet","setInitialPageSet","episodesPerPage","sourceUpdatedFromBackend","previousEpisodeRef","userNavigatedRef","hasLoadedResumeData","isAutoNavigating","lastPlayerEventNavigation","playerEventModeEnabled","navigationTimeouts","lastPlayerEventTime","ignoredLegacyNavigation","lastProgressSaveRef","isSavingProgressRef","type","season","episode","useAuth","setCurrentMediaItem","favoritesFetched","useEffect","newSeason","newEpisode","movieProgressPercent","useMemo","useCallback","targetEpisode","totalEpisodes","page","userId","userIdRef","timeout","route","controller","timeoutId","detailsData","videosData","recommendationsData","API_BASE_URL","res","err","anilistResponse","anilistData","lastWatchedWithProgress","getLastWatchedEpisodeWithProgress","newUrl","history","getSeriesHistory","progressData","getWatchProgressForMedia","data","maxPage","initialPage","currentEpisodeKey","episodeChanged","mediaId","isAnimeMovie","existingProgress","url","response","streamUrlData","finalStreamUrl","errorMessage","canRetry","handleProgressUpdate","messageType","seasonToSave","episodeToSave","now","progressKey","lastProgressSave","saveWatchProgress","prevHistory","historyCopy","index","h","newProgressData","messageListener","videoElement","handleLoadedMetadata","handleTimeUpdate","event","trustedDomains","origin","mediaData","e","mediaKey","media","normalizedProgress","readyTimeout","startFallbackTracking","progressHandler","handleVisibilityChange","iframe","jsxs","jsx","title","name","overview","vote_average","release_date","first_air_date","last_air_date","runtime","number_of_seasons","genres","poster_path","status","favorited","handleFavoriteClick","Helmet","getProxiedImageUrl","IMAGE_BASE_URL","startYear","endYear","g","q","source","Fragment","episodeHistory","progressPercent","d","prev","_","i","pageNum","item","MovieCard"],"mappings":"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"}