{"version":3,"file":"History-D_1t9_Z_.js","sources":["../../src/pages/History.jsx"],"sourcesContent":["import { h } from 'preact';\nimport './History.css';\nimport Helmet from 'preact-helmet';\nimport { useState, useEffect, useCallback, useRef } from 'preact/hooks';\n// Import getWatchHistory instead of getContinueWatching for actual watch history\nimport { getFullWatchHistory, deleteWatchItem, getBatchedWatchHistory } from '../utils/watchHistory';\nimport { useAuth } from '../context/Auth';\nimport { API_BASE_URL } from '../config';\nimport MovieCard from '../components/MovieCard';\nimport { useStore } from '../store';\n\n// Helper function to fetch with retry logic\nconst fetchWithRetry = async (url, maxRetries = 3, delay = 1000) => {\n    for (let i = 0; i < maxRetries; i++) {\n        try {\n            // Create a timeout promise for environments that don't support AbortSignal.timeout\n            const timeoutPromise = new Promise((_, reject) => {\n                setTimeout(() => reject(new Error('Request timeout')), 10000);\n            });\n\n            const fetchPromise = fetch(url, {\n                headers: {\n                    'Accept': 'application/json',\n                    'Content-Type': 'application/json',\n                }\n            });\n            \n            const response = await Promise.race([fetchPromise, timeoutPromise]);\n            \n            if (!response.ok) {\n                throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n            }\n            \n            return response;\n        } catch (error) {\n            console.warn(`Fetch attempt ${i + 1} failed for ${url}:`, error.message);\n            \n            if (i === maxRetries - 1) {\n                throw error;\n            }\n            \n            // Wait before retrying\n            await new Promise(resolve => setTimeout(resolve, delay * (i + 1)));\n        }\n    }\n};\n\nconst History = () => {\n    const { user } = useAuth();\n    const [history, setHistory] = useState([]);\n    const [loading, setLoading] = useState(true);\n    const [error, setError] = useState(null);\n    const [loadingMore, setLoadingMore] = useState(false);\n    const [hasMore, setHasMore] = useState(true);\n    const { removeContinueWatchingItem, fetchContinueWatching } = useStore();\n    const scrollTimeoutRef = useRef(null);\n    const loadingMoreRef = useRef(false);\n    const hasMoreRef = useRef(true);\n    \n    // Keep refs in sync with state\n    useEffect(() => {\n        loadingMoreRef.current = loadingMore;\n    }, [loadingMore]);\n    \n    useEffect(() => {\n        hasMoreRef.current = hasMore;\n    }, [hasMore]);\n\n    const fetchHistory = useCallback(async () => {\n        if (!user) {\n            setLoading(false);\n            return;\n        }\n        \n        setLoading(true);\n        setError(null);\n        setHistory([]);\n        setHasMore(true);\n        \n        try {\n            // Use batched loading to show results progressively\n            await loadHistoryBatch(0, true);\n        } catch (error) {\n            console.error('Error fetching watch history:', error);\n            setError('Failed to load watch history. Please try again.');\n            setHistory([]);\n        } finally {\n            setLoading(false);\n        }\n    }, [user]);\n\n    const loadHistoryBatch = useCallback(async (offset = 0, isInitial = false) => {\n        if (!user) return;\n        \n        // Check current hasMore state using ref to avoid stale closures\n        if (!isInitial && !hasMoreRef.current) return;\n        \n        if (!isInitial) setLoadingMore(true);\n        \n        try {\n            const batchSize = 20;\n            const batch = await getBatchedWatchHistory(user.id, offset, batchSize);\n            \n            if (batch.length === 0) {\n                setHasMore(false);\n                if (!isInitial) setLoadingMore(false);\n                return;\n            }\n            \n            setHistory(prev => {\n                // Avoid duplicates by filtering out items that already exist\n                const existingIds = new Set(prev.map(item => item.watch_id));\n                const newItems = batch.filter(item => !existingIds.has(item.watch_id));\n                return [...prev, ...newItems];\n            });\n            \n            // If we got fewer items than requested, we've reached the end\n            if (batch.length < batchSize) {\n                setHasMore(false);\n            }\n        } catch (error) {\n            console.error('Error loading history batch:', error);\n            if (isInitial) {\n                setError('Failed to load watch history. Please try again.');\n            }\n        } finally {\n            if (!isInitial) setLoadingMore(false);\n        }\n    }, [user]);\n\n    const loadMore = useCallback(() => {\n        // Use refs to get current state values and avoid stale closures\n        if (!loadingMoreRef.current && hasMoreRef.current) {\n            setHistory(currentHistory => {\n                loadHistoryBatch(currentHistory.length, false);\n                return currentHistory;\n            });\n        }\n    }, [loadHistoryBatch]);\n\n    // Infinite scroll handler\n    const handleScroll = useCallback(() => {\n        // Debounce scroll events\n        if (scrollTimeoutRef.current) {\n            clearTimeout(scrollTimeoutRef.current);\n        }\n        \n        scrollTimeoutRef.current = setTimeout(() => {\n            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;\n            const windowHeight = window.innerHeight;\n            const documentHeight = document.documentElement.scrollHeight;\n            \n            // Trigger load more when user is within 200px of the bottom\n            const threshold = 200;\n            const isNearBottom = scrollTop + windowHeight >= documentHeight - threshold;\n            \n            if (isNearBottom && !loadingMoreRef.current && hasMoreRef.current) {\n                loadMore();\n            }\n        }, 100); // 100ms debounce\n    }, [loadMore, loadingMore, hasMore]);\n\n    useEffect(() => {\n        fetchHistory();\n    }, [fetchHistory, user]);\n\n    // Set up infinite scroll\n    useEffect(() => {\n        window.addEventListener('scroll', handleScroll, { passive: true });\n        \n        return () => {\n            window.removeEventListener('scroll', handleScroll);\n            if (scrollTimeoutRef.current) {\n                clearTimeout(scrollTimeoutRef.current);\n            }\n        };\n    }, [handleScroll]);\n\n    const handleDelete = async (itemToDelete) => {\n        // Optimistically remove the item from the UI using the unique watch_id\n        setHistory(history.filter(item => item.watch_id !== itemToDelete.watch_id));\n        \n        // Optimistically remove from the global \"Continue Watching\" state\n        removeContinueWatchingItem(itemToDelete.media_id);\n\n        try {\n            // Call the delete function from the utils\n            await deleteWatchItem(user.id, itemToDelete);\n\n            // Refetch continue watching to ensure it's up to date\n            await fetchContinueWatching(user.id);\n        } catch (error) {\n            console.error(\"Failed to delete item or refetch continue watching:\", error);\n            // Optionally, add the item back to the history list on failure\n            // and show a toast notification to the user.\n            // For now, we'll just log the error.\n        }\n    };\n\n    const handleRetry = () => {\n        fetchHistory();\n    };\n\n    if (loading) {\n        return <div class=\"container\"><p>Loading watch history...</p></div>;\n    }\n\n    if (error) {\n        return (\n            <div class=\"container\">\n                <Helmet>\n                    <title>Watch History - Fylm</title>\n                </Helmet>\n                <h1>Watch History</h1>\n                <div class=\"error-message\">\n                    <p>{error}</p>\n                    <button onClick={handleRetry} class=\"retry-button\">Retry</button>\n                </div>\n            </div>\n        );\n    }\n\n    return (\n        <div class=\"container\">\n            <Helmet>\n                <title>Watch History - Fylm</title>\n            </Helmet>\n            <h1>Watch History</h1>\n            {history.length > 0 ? (\n                <>\n                    <div class=\"movie-grid\">\n                        {history.map(item => {\n                            return (\n                                <MovieCard \n                                    key={item.watch_id} \n                                    item={item} \n                                    type={item.type}\n                                    progress={item.progress_seconds}\n                                    duration={item.duration_seconds}\n                                    showDeleteButton={true}\n                                    onDelete={handleDelete}\n                                    useFullResolution={true}\n                                />\n                            );\n                        })}\n                    </div>\n                    {loadingMore && (\n                        <div class=\"loading-more-container\">\n                            <p class=\"loading-more-text\">Loading more items...</p>\n                        </div>\n                    )}\n                    {!hasMore && history.length > 0 && (\n                        <div class=\"end-of-list-container\">\n                            <p class=\"end-of-list-text\">You've reached the end of your watch history</p>\n                        </div>\n                    )}\n                </>\n            ) : (\n                !loading && <p>Your watch history is empty.</p>\n            )}\n        </div>\n    );\n};\n\nexport default History;"],"names":["History","user","useAuth","history","setHistory","useState","loading","setLoading","error","setError","loadingMore","setLoadingMore","hasMore","setHasMore","removeContinueWatchingItem","fetchContinueWatching","useStore","scrollTimeoutRef","useRef","loadingMoreRef","hasMoreRef","useEffect","fetchHistory","useCallback","loadHistoryBatch","offset","isInitial","batch","getBatchedWatchHistory","prev","existingIds","item","newItems","loadMore","currentHistory","handleScroll","scrollTop","windowHeight","documentHeight","handleDelete","itemToDelete","deleteWatchItem","handleRetry","jsx","jsxs","Helmet","Fragment","MovieCard"],"mappings":"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"}