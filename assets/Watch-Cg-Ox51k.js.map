{"version":3,"file":"Watch-Cg-Ox51k.js","sources":["../../src/pages/Watch.jsx"],"sourcesContent":["import { h } from 'preact';\nimport { useState, useEffect, useRef, useMemo, useCallback } from 'preact/hooks';\nimport { route } from 'preact-router';\nimport Helmet from 'preact-helmet';\nimport { useStore } from '../store';\nimport MovieCard from '../components/MovieCard';\nimport { getWatchProgressForMedia, saveWatchProgress, getSeriesHistory, getLastWatchedEpisode, getLastWatchedEpisodeWithProgress, syncOfflineProgress } from '../utils/watchHistory';\nimport { useAuth } from '../context/Auth';\nimport { useMiniPlayer } from '../context/MiniPlayer';\nimport { addFavoriteShow, removeFavoriteShow } from '../utils/favorites';\nimport './Watch.css';\nimport { API_BASE_URL, IMAGE_BASE_URL, getProxiedImageUrl } from '../config';\nimport { supabase } from '../supabase';\nimport { optimizeVideoForIOS, isIOS } from '../utils/iosUtils';\n\nconst Watch = (props) => {\n    const [mediaDetails, setMediaDetails] = useState(null);\n    const [videos, setVideos] = useState([]);\n    const [recommendations, setRecommendations] = useState([]);\n    const [streamUrl, setStreamUrl] = useState('');\n    const [loading, setLoading] = useState(true);\n    const [isPlaying, setIsPlaying] = useState(false);\n    const playerContainerRef = useRef(null);\n    const [currentSeason, setCurrentSeason] = useState(null);\n    const [currentEpisode, setCurrentEpisode] = useState(null);\n    const [currentSource, setCurrentSource] = useState('videasy');\n    const [availableSources, setAvailableSources] = useState(['videasy', 'vidsrc', 'embedsu']);\n    const [seasonDetails, setSeasonDetails] = useState(null);\n    const [episodesLoading, setEpisodesLoading] = useState(false);\n    const [isDubbed, setIsDubbed] = useState(false);\n    // Removed showNextEpisodePrompt and nextEpisodeCountdown - Videasy handles this automatically\n    const [streamError, setStreamError] = useState(null);\n    const [isRetrying, setIsRetrying] = useState(false);\n    const [streamTimeoutError, setStreamTimeoutError] = useState(false);\n    const streamTimeoutRef = useRef();\n    const [error, setError] = useState(null);\n    const { id, type, season, episode } = props.matches;\n    const [tmdbId, setTmdbId] = useState(type === 'anime' ? null : id);\n    const [mediaType, setMediaType] = useState(type === 'anime' ? 'anime' : type);\n    const [showTrailer, setShowTrailer] = useState(false);\n\n\n    const [isDirectSource, setIsDirectSource] = useState(false);\n    const [qualities, setQualities] = useState([]);\n    const videoRef = useRef(null);\n    const [seriesWatchHistory, setSeriesWatchHistory] = useState([]);\n    const [movieProgress, setMovieProgress] = useState(null);\n    const [playerReady, setPlayerReady] = useState(false);\n    const [progressToResume, setProgressToResume] = useState(0);\n    const [currentEpisodePage, setCurrentEpisodePage] = useState(1);\n    const [paginationPage, setPaginationPage] = useState(1);\n    const [initialPageSet, setInitialPageSet] = useState(false);\n    const episodesPerPage = 10;\n    const sourceUpdatedFromBackend = useRef(false); // Track if source change is from backend\n    const previousEpisodeRef = useRef(null); // Track previous episode to detect navigation\n    const userNavigatedRef = useRef(false); // Track if user manually navigated to prevent auto-override\n    const hasLoadedResumeData = useRef(false); // Track if we've already loaded resume data once\n    const isAutoNavigating = useRef(false); // Track if navigation is driven by the player\n    const lastPlayerEventNavigation = useRef(null); // Track last PLAYER_EVENT navigation to prevent conflicts\n    const playerEventModeEnabled = useRef(false); // Track if PLAYER_EVENT mode is active\n    const navigationTimeouts = useRef(new Set()); // Track active navigation timeouts\n    const lastPlayerEventTime = useRef(0); // Debounce rapid PLAYER_EVENT messages\n    const lastRouteChange = useRef(0); // Debounce route changes to prevent loops\n    const routeChangeDebounceTime = 1000; // 1 second debounce for route changes\n    const ignoredLegacyNavigation = useRef(null); // Track ignored legacy navigation to prevent log spam\n    const lastHistoryUpdateRef = useRef({});\n    const lastProgressSaveTime = useRef(0); // For throttling\n    const pendingSaveTimeout = useRef(null); // For debouncing\n    const currentProgressRef = useRef({ progress: 0, duration: 0 }); // Track current progress for MiniPlayer\n\n    const { user, session } = useAuth(); // Get authentication state\n    const userId = user?.id;\n    const tmdbType = 'tv'; // Always use 'tv' for TMDB anime lookups\n    const { openMiniPlayer, closeMiniPlayer, isActive: isMiniPlayerActive, isSupported: isMiniPlayerSupported } = useMiniPlayer();\n\n    // Debug authentication status on component load\n    useEffect(() => {\n        const checkAuthStatus = async () => {\n            const { data: { session }, error } = await supabase.auth.getSession();\n            if (error) {\n                console.error('ðŸ” Auth check error:', error);\n            } else if (session) {\n                console.log('ðŸ” Auth status: Authenticated user', session.user.id);\n            } else {\n                console.log('ðŸ” Auth status: No active session');\n            }\n        };\n        checkAuthStatus();\n    }, []);\n\n    const { setCurrentMediaItem, favoritesFetched, fetchContinueWatching, isShowFavorited } = useStore();\n\n    // Initialize season and episode from URL parameters immediately\n    useEffect(() => {\n        if (type === 'tv' || type === 'anime') {\n            const hasExplicitEpisode = season && episode && !isNaN(parseInt(season)) && !isNaN(parseInt(episode));\n            if (hasExplicitEpisode) {\n                const newSeason = parseInt(season, 10);\n                const newEpisode = parseInt(episode, 10);\n                setCurrentSeason(newSeason);\n                setCurrentEpisode(newEpisode);\n            } else {\n                // For anime, default to season 1, episode 1\n                // For TV shows, also default to season 1, episode 1\n                setCurrentSeason(1);\n                setCurrentEpisode(1);\n            }\n        } else {\n            // For movies, set to null\n            setCurrentSeason(null);\n            setCurrentEpisode(null);\n        }\n    }, [type, season, episode]);\n\n    // Calculate movie progress percentage with a memoized hook for efficiency\n    const movieProgressPercent = useMemo(() => {\n        if (type !== 'movie' || !movieProgress || !movieProgress.progress_seconds || movieProgress.progress_seconds <= 0) {\n            return 0;\n        }\n        if (movieProgress.duration_seconds > 0) {\n            return Math.min(100, (movieProgress.progress_seconds / movieProgress.duration_seconds) * 100);\n        }\n        // Fallback for when duration is missing: 5% if over 30s, otherwise 2%\n        return movieProgress.progress_seconds > 30 ? 5 : 2;\n    }, [type, movieProgress]);\n\n    // Calculate and set initial episode page based on current episode\n    const calculateInitialEpisodePage = useCallback((targetEpisode, totalEpisodes) => {\n        if (!targetEpisode || !totalEpisodes) return 1;\n\n        const page = Math.ceil(targetEpisode / episodesPerPage);\n        return Math.max(1, Math.min(page, Math.ceil(totalEpisodes / episodesPerPage)));\n    }, [episodesPerPage]);\n\n    // Create stable user ID reference to prevent unnecessary re-renders\n    const userIdRef = useRef(userId);\n\n    // Update ref when userId changes but don't trigger re-renders\n    useEffect(() => {\n        userIdRef.current = userId;\n    }, [userId]);\n\n    // Helper function to debounce route changes and prevent loops\n    const debouncedRoute = (url, replace = false) => {\n        const now = Date.now();\n        if (now - lastRouteChange.current < routeChangeDebounceTime) {\n            console.log('ðŸš« Route change debounced to prevent refresh loop');\n            return;\n        }\n        lastRouteChange.current = now;\n        route(url, replace);\n    };\n\n    const handleTrailerClick = () => {\n        const trailer = videos.find(video => video.type === 'Trailer' && video.site === 'YouTube');\n        if (trailer) {\n            setShowTrailer(true);\n        } else {\n            // Provide feedback if no trailer is available\n            alert(\"No trailer available for this movie.\");\n        }\n    };\n\n    // Clear all navigation timeouts when component unmounts or episode changes\n    useEffect(() => {\n        return () => {\n            navigationTimeouts.current.forEach(timeout => clearTimeout(timeout));\n            navigationTimeouts.current.clear();\n        };\n    }, [currentSeason, currentEpisode]);\n\n    // Handle fullscreen events to refresh auth when entering/exiting fullscreen\n    useEffect(() => {\n        const handleFullscreenChange = async () => {\n            const isFullscreen = document.fullscreenElement ||\n                document.webkitFullscreenElement ||\n                document.mozFullScreenElement;\n\n            if (isFullscreen) {\n                console.log('ðŸ“± Entered fullscreen mode');\n                // Note: Session management is handled by Auth context\n                // No manual session refresh needed here\n            } else {\n                console.log('ðŸ“± Exited fullscreen mode, syncing progress...');\n                // Try to sync any offline progress saved during fullscreen\n                // Use multiple attempts to ensure sync happens\n                const syncAttempts = [500, 2000, 5000]; // Try at 0.5s, 2s, and 5s\n                syncAttempts.forEach((delay, index) => {\n                    setTimeout(() => {\n                        if (userId) {\n                            console.log(`ðŸ”„ Sync attempt ${index + 1} after fullscreen exit`);\n                            syncOfflineProgress(userId).then(result => {\n                                if (result) {\n                                    console.log(`âœ… Fullscreen sync attempt ${index + 1} successful`);\n                                    // Refresh continue watching after successful sync\n                                    fetchContinueWatching();\n                                }\n                            }).catch(error => {\n                                console.error(`âŒ Sync attempt ${index + 1} failed:`, error);\n                            });\n                        }\n                    }, delay);\n                });\n            }\n        };\n\n        document.addEventListener('fullscreenchange', handleFullscreenChange);\n        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);\n        document.addEventListener('mozfullscreenchange', handleFullscreenChange);\n\n        return () => {\n            document.removeEventListener('fullscreenchange', handleFullscreenChange);\n            document.removeEventListener('webkitfullscreenchange', handleFullscreenChange);\n            document.removeEventListener('mozfullscreenchange', handleFullscreenChange);\n        };\n    }, [userId]);\n\n    useEffect(() => {\n        // When the component mounts or mediaDetails changes, update the global state\n        if (mediaDetails) {\n            setCurrentMediaItem({ ...mediaDetails, type });\n        }\n\n        // When the component unmounts, clear the global state\n        return () => {\n            setCurrentMediaItem(null);\n        };\n    }, [mediaDetails, type, setCurrentMediaItem]);\n\n    // Handle mini-player activation on navigation away\n    useEffect(() => {\n        // Close mini-player when returning to the Watch page\n        if (isMiniPlayerActive) {\n            console.log('ðŸ‘ï¸ Watch page mounted, closing mini-player');\n            closeMiniPlayer();\n        }\n\n        // Capture refs early so they're available during cleanup\n        // This is crucial because refs get cleared during unmount\n        const captureRefs = () => {\n            return {\n                iframe: document.querySelector('iframe[title=\"Video Player\"]'),\n                container: playerContainerRef.current\n            };\n        };\n\n        // Also handle component unmount for SPA navigation\n        return () => {\n            console.log('ðŸšª Watch component unmounting - checking mini-player conditions');\n\n            // Capture element references at cleanup time\n            const { iframe, container } = captureRefs();\n            const hasVideo = iframe && streamUrl && playerReady;\n\n            console.log('ðŸ” Mini-player pre-flight check:', {\n                hasIframe: !!iframe,\n                hasStreamUrl: !!streamUrl,\n                playerReady,\n                hasVideo,\n                isMiniPlayerSupported,\n                isMiniPlayerActive,\n                hasMediaDetails: !!mediaDetails,\n                hasContainer: !!container\n            });\n\n            if (hasVideo && isMiniPlayerSupported && !isMiniPlayerActive && mediaDetails && container) {\n                console.log('âœ… All conditions met, activating mini-player');\n\n                // Prepare video information for mini-player\n                const videoInfo = {\n                    title: mediaDetails.title || mediaDetails.name || 'Video',\n                    url: window.location.href,\n                    type: type,\n                    id: id,\n                    season: currentSeason,\n                    id: id,\n                    season: currentSeason,\n                    episode: currentEpisode,\n                    progress: currentProgressRef.current?.progress || 0,\n                    duration: currentProgressRef.current?.duration || 0\n                };\n\n                console.log('ðŸ“ž Calling openMiniPlayer with:', { videoInfo });\n                // Call synchronously during unmount\n                try {\n                    openMiniPlayer(iframe, container, videoInfo);\n                } catch (err) {\n                    console.error('âŒ Failed to open mini-player:', err);\n                }\n            } else {\n                console.log('âŒ Conditions NOT met for mini-player');\n                if (!container) {\n                    console.error('âŒ Container not found - ref not attached to DOM element');\n                }\n            }\n        };\n    }, [\n        streamUrl,\n        playerReady,\n        isMiniPlayerSupported,\n        isMiniPlayerActive,\n        mediaDetails,\n        type,\n        id,\n        currentSeason,\n        currentEpisode,\n        openMiniPlayer,\n        closeMiniPlayer\n    ]);\n\n    useEffect(() => {\n        if (!id || !type) {\n            route('/');\n            return;\n        }\n\n        // Determine the correct handling based on the type parameter\n        if (type === 'anime') {\n            // For anime route, we use the anilist ID directly, so tmdbId can be null initially.\n            // The API will handle the conversion.\n            setMediaType('anime');\n            setTmdbId(null); // Explicitly set to null to trigger fetches correctly\n        } else if (type === 'tv' || type === 'movie') {\n            // For regular TMDB content (TV shows and movies), set the IDs immediately\n            setTmdbId(id);\n            setMediaType(type);\n        } else {\n            // Handle any other cases by defaulting to the provided type\n            setTmdbId(id);\n            setMediaType(type);\n        }\n\n    }, [id, type]);\n\n    useEffect(() => {\n        // For non-anime, we need a tmdbId. For anime, we use the main `id` from props.\n        if ((type !== 'anime' && !tmdbId) || (type === 'anime' && !id)) return;\n\n\n        // Reset state on new content\n        setStreamUrl('');\n        setIsDirectSource(false);\n        setQualities([]);\n        setMediaDetails(null);\n        setLoading(true);\n        // Removed prompt reset - Videasy handles this automatically\n        setSeriesWatchHistory([]);\n        // Reset navigation tracking for new content\n        userNavigatedRef.current = false;\n        hasLoadedResumeData.current = false;\n        isAutoNavigating.current = false;\n        lastPlayerEventNavigation.current = null;\n        playerEventModeEnabled.current = false;\n        // Reset pagination state for new content\n        setCurrentEpisodePage(1);\n        setInitialPageSet(false);\n        // Clear any pending navigation timeouts\n        navigationTimeouts.current.forEach(timeout => clearTimeout(timeout));\n        navigationTimeouts.current.clear();\n        // Reset debounce timer\n        lastPlayerEventTime.current = 0;\n        // Reset ignored navigation log\n        ignoredLegacyNavigation.current = null;\n\n        const fetchAllData = async () => {\n            setLoading(true);\n            try {\n                // Create abort controller for timeout handling\n                const controller = new AbortController();\n                const timeoutId = setTimeout(() => controller.abort(), 15000); // 15 second timeout\n\n                // Fetch data with better error handling\n                const anilistId = id; // Use the raw ID from props for anime\n\n                // Use enhanced endpoint for anime content\n                const detailsUrl = type === 'anime'\n                    ? `${API_BASE_URL}/tmdb/anime/${anilistId}/enhanced`\n                    : `${API_BASE_URL}/tmdb/${mediaType}/${tmdbId}`;\n\n                // Videos are now included in enhanced endpoint for anime\n                const videosUrl = type === 'anime'\n                    ? null // Will get videos from enhanced endpoint\n                    : `${API_BASE_URL}/tmdb/${mediaType}/${tmdbId}/videos`;\n\n                const recommendationsUrl = type === 'anime'\n                    ? `${API_BASE_URL}/tmdb/anime/${anilistId}/recommendations`\n                    : `${API_BASE_URL}/tmdb/${mediaType}/${tmdbId}/recommendations`;\n\n                const fetchData = async (url, errorMessage) => {\n                    if (!url) return null; // Skip null URLs\n\n                    try {\n                        const res = await fetch(url, { signal: controller.signal });\n                        if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);\n                        const data = await res.json();\n                        // When using the anime route, update the tmdbId from the response\n                        if (type === 'anime' && data._conversion?.tmdbId) {\n                            setTmdbId(data._conversion.tmdbId);\n                            // DO NOT change the mediaType. It should remain 'anime'.\n                        }\n                        // For enhanced endpoint, data already includes tmdb_id\n                        if (type === 'anime' && data.tmdb_id) {\n                            setTmdbId(data.tmdb_id);\n                        }\n                        return data;\n                    } catch (err) {\n                        console.error(`${errorMessage}:`, err);\n                        // For videos/recs, return empty results to avoid breaking the page\n                        if (errorMessage.includes('videos') || errorMessage.includes('recommendations')) {\n                            return { results: [] };\n                        }\n                        throw err;\n                    }\n                };\n\n                // For anime, fetch enhanced data only\n                // For non-anime, fetch details and videos separately\n                let detailsData, videosData, recommendationsData;\n\n                if (type === 'anime') {\n                    detailsData = await fetchData(detailsUrl, 'Error fetching anime details');\n                    videosData = { results: detailsData?.videos?.results || [] };\n                    recommendationsData = await fetchData(recommendationsUrl, 'Error fetching recommendations');\n                } else {\n                    [detailsData, videosData, recommendationsData] = await Promise.all([\n                        fetchData(detailsUrl, 'Error fetching media details'),\n                        fetchData(videosUrl, 'Error fetching videos'),\n                        fetchData(recommendationsUrl, 'Error fetching recommendations')\n                    ]);\n                }\n\n                clearTimeout(timeoutId);\n                setMediaDetails(detailsData);\n                setVideos(videosData.results || []);\n                setRecommendations(recommendationsData.results || []);\n\n                // Season and episode initialization is now handled in a separate effect\n            } catch (error) {\n                setMediaDetails(null);\n                setVideos([]);\n                setRecommendations([]);\n            } finally {\n                setLoading(false);\n            }\n        };\n        fetchAllData();\n    }, [tmdbId, mediaType, season, episode, userId]);\n\n    // Separate effect to handle authentication-dependent data loading - ONLY run once to avoid overriding user selections\n    useEffect(() => {\n        const loadUserSpecificData = async () => {\n            if (!userId || !mediaDetails || !id || !type) {\n                // Reset progress states when no user is authenticated\n                if (type === 'movie') {\n                    setMovieProgress(null);\n                } else if (type === 'tv' || type === 'anime') {\n                    setSeriesWatchHistory([]);\n                }\n                return;\n            }\n\n            try {\n                // Only fetch user-specific data when user is authenticated\n                if ((type === 'tv' || type === 'anime') && mediaDetails.seasons && mediaDetails.seasons.length > 0) {\n                    const hasExplicitEpisode = season && episode && !isNaN(parseInt(season)) && !isNaN(parseInt(episode));\n\n                    // Modified logic: Always try to get continue watching when no explicit episode in URL\n                    if (!hasExplicitEpisode && !hasLoadedResumeData.current && currentSeason !== null && currentEpisode !== null) {\n                        console.log('ðŸŽ¬ Checking for continue watching episode...');\n                        const lastWatchedWithProgress = await getLastWatchedEpisodeWithProgress(userId, id, tmdbType);\n                        if (lastWatchedWithProgress && lastWatchedWithProgress.season_number && lastWatchedWithProgress.episode_number) {\n                            console.log(`ðŸ”„ Continue watching: S${lastWatchedWithProgress.season_number}E${lastWatchedWithProgress.episode_number}`);\n                            // Use a timeout to prevent immediate re-render loops\n                            setTimeout(() => {\n                                setCurrentSeason(lastWatchedWithProgress.season_number);\n                                setCurrentEpisode(lastWatchedWithProgress.episode_number);\n                                // Update URL to reflect the continue watching episode\n                                const newUrl = `/watch/${type}/${id}/season/${lastWatchedWithProgress.season_number}/episode/${lastWatchedWithProgress.episode_number}`;\n                                route(newUrl, true);\n                            }, 100);\n                        } else {\n                            console.log('ðŸ“­ No continue watching data found, starting from beginning');\n                        }\n                        hasLoadedResumeData.current = true;\n                    }\n                }\n\n                if (type === 'tv' || type === 'anime') {\n                    const history = await getSeriesHistory(userId, id, tmdbType);\n                    console.log(`ðŸ“º [Watch] Series history loaded for ${type} ${id}:`, history);\n                    setSeriesWatchHistory(history);\n                }\n\n                // Load progress data for all media types\n                const progressData = await getWatchProgressForMedia(userId, id, type);\n                console.log('Progress data loaded:', progressData);\n                setMovieProgress(progressData);\n            } catch (error) {\n                console.error('Error loading user-specific data:', error);\n            }\n        };\n\n        loadUserSpecificData();\n    }, [userId, mediaDetails, id, type, season, episode, tmdbType]); // Remove season and episode from dependencies to prevent re-running when user changes selection\n\n    // Reset pagination when season changes, but respect initial page setting\n    useEffect(() => {\n        if (currentSeason !== null && !initialPageSet) {\n            setCurrentEpisodePage(1);\n        }\n    }, [currentSeason]);\n\n    // Pagination state is now completely independent\n\n    // Removed auto-navigation - pagination is now completely independent\n\n    useEffect(() => {\n        const fetchSeasonDetails = async () => {\n            if ((type !== 'tv' && type !== 'anime') || !currentSeason || currentSeason === null) return;\n            // Use tmdbId for TV shows, and the original `id` (AniList) for anime\n            const mediaIdForRequest = type === 'anime' ? id : tmdbId;\n            if (!mediaIdForRequest) return; // Don't fetch if the necessary ID isn't available yet\n\n            setEpisodesLoading(true);\n            try {\n                const url = type === 'anime' ?\n                    `${API_BASE_URL}/tmdb/anime/${mediaIdForRequest}/season/${currentSeason}` :\n                    `${API_BASE_URL}/tmdb/${mediaType}/${mediaIdForRequest}/season/${currentSeason}`;\n\n                const response = await fetch(url);\n                if (!response.ok) {\n                    throw new Error(`Failed to fetch season details: ${response.statusText}`);\n                }\n                const data = await response.json();\n                setSeasonDetails(data);\n\n                // If this is the initial load, set the episode page based on the current episode\n                if (!initialPageSet) {\n                    const totalEpisodes = data.episodes.length;\n                    const page = calculateInitialEpisodePage(currentEpisode, totalEpisodes);\n                    setCurrentEpisodePage(page);\n                    setInitialPageSet(true);\n                }\n\n            } catch (error) {\n                console.error(\"Error fetching season details:\", error);\n                setSeasonDetails(null);\n            } finally {\n                setEpisodesLoading(false);\n            }\n        };\n        fetchSeasonDetails();\n    }, [id, type, tmdbType, currentSeason, currentEpisode, initialPageSet, calculateInitialEpisodePage]);\n\n    useEffect(() => {\n        // Check if this is due to episode navigation\n        const currentEpisodeKey = `${currentSeason}-${currentEpisode}`;\n        const episodeChanged = previousEpisodeRef.current && previousEpisodeRef.current !== currentEpisodeKey;\n        previousEpisodeRef.current = currentEpisodeKey;\n\n        if (sourceUpdatedFromBackend.current && !episodeChanged) {\n            sourceUpdatedFromBackend.current = false;\n            return;\n        }\n\n        if (episodeChanged) {\n            sourceUpdatedFromBackend.current = false;\n        }\n\n        const fetchStreamUrl = async () => {\n            if (!tmdbId || !mediaType) return;\n\n\n            // Use AniList ID for anime, TMDB ID for others.\n            const streamId = type === 'anime' ? id : tmdbId;\n            if (!streamId) return;\n\n            setStreamError(null);\n            setStreamTimeoutError(false);\n            if (streamTimeoutRef.current) clearTimeout(streamTimeoutRef.current);\n            streamTimeoutRef.current = setTimeout(() => setStreamTimeoutError(true), 10000);\n\n            const isAnimeMovie = type === 'anime' && mediaDetails && (!mediaDetails.seasons || mediaDetails.seasons.length === 0);\n\n            if ((type === 'tv' || type === 'anime') && !isAnimeMovie && (currentSeason === null || currentEpisode === null)) {\n                console.log(\"Season/episode not set, aborting stream URL fetch.\");\n                clearTimeout(streamTimeoutRef.current);\n                return;\n            }\n\n            try {\n                // Use `type` from props for the stream-url endpoint, `streamId` for the ID\n                let url = `${API_BASE_URL}/stream-url?type=${type}&id=${streamId}&source=${currentSource}`;\n\n                if (type === 'tv' || (type === 'anime' && !isAnimeMovie)) {\n                    url += `&season=${currentSeason}&episode=${currentEpisode}`;\n                }\n\n                if (type === 'anime' && isDubbed) {\n                    url += `&dub=true`;\n                }\n\n                if (currentSource === 'videasy') {\n                    if (progressToResume > 0) url += `&progress=${Math.round(progressToResume)}`;\n                    if (type === 'tv' || type === 'anime') {\n                        url += `&nextEpisode=true&episodeSelector=true&autoplayNextEpisode=true`;\n                    }\n                }\n\n                console.log(`Fetching stream URL: ${url}`);\n                const response = await fetch(url);\n                if (!response.ok) throw new Error(`Server responded with ${response.status}`);\n                const data = await response.json();\n\n                clearTimeout(streamTimeoutRef.current);\n\n                if (data.url) {\n                    console.log(`Stream URL generated: ${data.url}`);\n                    setStreamUrl(data.url);\n                    setIsDirectSource(data.isDirectSource || false);\n                    setQualities(data.qualities || []);\n                    if (data.availableSources && data.availableSources.length > 0) {\n                        setAvailableSources(data.availableSources);\n                    }\n                    if (data.currentSource) {\n                        sourceUpdatedFromBackend.current = true;\n                        setCurrentSource(data.currentSource);\n                    }\n                    setStreamError(null);\n                    setPlayerReady(true);\n                } else {\n                    throw new Error(data.message || 'No stream URL returned from API');\n                }\n            } catch (error) {\n                clearTimeout(streamTimeoutRef.current);\n                console.error('Error fetching stream URL:', error.message);\n                setStreamError(`Failed to load video: ${error.message}. Try changing the source or refreshing.`);\n                setPlayerReady(false);\n            }\n        };\n\n        fetchStreamUrl();\n    }, [tmdbId, mediaType, currentSeason, currentEpisode, currentSource, isDubbed, mediaDetails, progressToResume, userId]);\n\n    // Removed handleNextEpisode and countdown logic - Videasy handles episode navigation automatically\n\n    // Add immediate watch history entry when user navigates to watch page (throttled)\n    // This useEffect hook has been removed as it was causing logic conflicts.\n    // The saveWatchProgress function in the database now handles all history updates.\n    /*\n    useEffect(() => {\n        if (user && mediaDetails) {\n            const historyKey = `${id}-${type}-${currentSeason}-${currentEpisode}`;\n            const now = Date.now();\n            const lastHistoryUpdate = lastHistoryUpdateRef.current;\n            \n            if (!lastHistoryUpdate[historyKey] || now - lastHistoryUpdate[historyKey] > 5000) {\n                console.log('ðŸ“ Adding immediate watch history entry:', {\n                    mediaId: id,\n                    type,\n                    season: currentSeason,\n                    episode: currentEpisode,\n                    title: mediaDetails.title || mediaDetails.name\n                });\n                \n                addWatchHistoryEntry(\n                    { ...mediaDetails, id: mediaDetails.id, type, season: currentSeason, episode: currentEpisode }\n                ).then(() => {\n                    console.log('âœ… Watch history entry added successfully');\n                }).catch(error => {\n                    console.error('âŒ Failed to add watch history entry:', error);\n                });\n                \n                lastHistoryUpdate[historyKey] = now;\n            }\n        }\n    }, [user, mediaDetails, type, currentSeason, currentEpisode, id]);\n    */\n\n    // Progress tracking for different streaming services\n    useEffect(() => {\n        const currentUserId = userIdRef.current;\n        if (currentUserId) {\n            console.log('ðŸ” Progress tracking setup:', {\n                hasUser: true,\n                userId: currentUserId,\n                hasMediaDetails: !!mediaDetails\n            });\n        }\n\n        if (!currentUserId || !mediaDetails) {\n            if (currentUserId && !mediaDetails) {\n                console.log('âš ï¸ Progress tracking disabled - media details not yet available');\n            }\n            return;\n        }\n\n        // This function will be called by the message event listener\n        const handleProgressUpdate = async (progressData, messageType) => {\n            console.log(`ðŸ“Š Progress update received via ${messageType}: `, progressData);\n\n            // Determine the season and episode to save progress for.\n            // Prioritize data from the event, then fall back to component state.\n            const seasonToSave = progressData.season || currentSeason;\n            const episodeToSave = progressData.episode || currentEpisode;\n\n            // Update ref for MiniPlayer\n            if (progressData && progressData.progress >= 0) {\n                currentProgressRef.current = {\n                    progress: progressData.progress,\n                    duration: progressData.duration\n                };\n            }\n\n            if (progressData && progressData.progress >= 0 && progressData.duration > 0) {\n                const now = Date.now();\n                if (now - lastProgressSaveTime.current < 2000) { // Increased to 2-second throttle\n                    return;\n                }\n\n                // Clear any pending save to prevent duplicate calls\n                if (pendingSaveTimeout.current) {\n                    clearTimeout(pendingSaveTimeout.current);\n                }\n\n                lastProgressSaveTime.current = now;\n\n                try {\n                    console.log(`ðŸŽ¬ Attempting to save progress for ${type} ${id}:`, {\n                        progress: progressData.progress,\n                        duration: progressData.duration,\n                        season: seasonToSave,\n                        episode: episodeToSave\n                    });\n\n                    const saveResult = await saveWatchProgress(\n                        currentUserId,\n                        { ...mediaDetails, id: mediaDetails.id, type, season: seasonToSave, episode: episodeToSave },\n                        progressData.progress,\n                        progressData.duration,\n                        false, // forceHistoryEntry\n                        session // Pass session from Auth context\n                    ).catch(error => {\n                        console.error('âŒ Progress save error caught:', error);\n                        if (error.message?.includes('timeout') || error.message?.includes('auth')) {\n                            // For auth timeouts, use localStorage fallback\n                            const key = `offline_progress_${type}_${id}_${seasonToSave || 0}_${episodeToSave || 0}`;\n                            const offlineData = {\n                                media_id: id,\n                                media_type: type,\n                                season_number: seasonToSave,\n                                episode_number: episodeToSave,\n                                progress_seconds: progressData.progress,\n                                duration_seconds: progressData.duration,\n                                timestamp: new Date().toISOString()\n                            };\n                            localStorage.setItem(key, JSON.stringify(offlineData));\n                            console.log('ðŸ“± Saved to localStorage after error');\n                            return true; // Pretend success for UI consistency\n                        }\n                        return false;\n                    });\n\n                    if (saveResult) {\n                        console.log('âœ… Progress saved successfully');\n                        fetchContinueWatching(); // Refresh continue watching list\n\n                        // Update state in real-time only if the progress applies to the currently viewed item\n                        if (seasonToSave === currentSeason && episodeToSave === currentEpisode) {\n                            // Use the actual saved progress data if available, otherwise fall back to local data\n                            const progressToUse = (typeof saveResult === 'object' && saveResult.progress_seconds !== undefined)\n                                ? saveResult\n                                : {\n                                    progress_seconds: progressData.progress,\n                                    duration_seconds: progressData.duration\n                                };\n\n                            console.log('ðŸ“Š Using progress data for state update:', progressToUse);\n\n                            if (type === 'movie') {\n                                setMovieProgress(progressToUse);\n                            } else if (type === 'tv' || type === 'anime') {\n                                setSeriesWatchHistory(prevHistory => {\n                                    const historyCopy = [...prevHistory];\n                                    const index = historyCopy.findIndex(\n                                        h => h.season_number === seasonToSave && h.episode_number === episodeToSave\n                                    );\n\n                                    const newProgressData = {\n                                        media_id: parseInt(id, 10),\n                                        media_type: type,\n                                        season_number: seasonToSave,\n                                        episode_number: episodeToSave,\n                                        progress_seconds: progressToUse.progress_seconds,\n                                        duration_seconds: progressToUse.duration_seconds,\n                                    };\n\n                                    if (index > -1) {\n                                        historyCopy[index] = { ...historyCopy[index], ...newProgressData };\n                                    } else {\n                                        historyCopy.push(newProgressData);\n                                    }\n\n                                    return historyCopy;\n                                });\n                            }\n                        }\n                    } else {\n                        console.error('âŒ Failed to save progress, will retry on next update');\n                    }\n                } catch (error) {\n                    console.error('âŒ An unexpected error occurred while saving progress:', error);\n                    // For any unexpected error, still try to use localStorage\n                    try {\n                        const key = `offline_progress_${type}_${id}_${seasonToSave || 0}_${episodeToSave || 0}`;\n                        const offlineData = {\n                            media_id: id,\n                            media_type: type,\n                            season_number: seasonToSave,\n                            episode_number: episodeToSave,\n                            progress_seconds: progressData.progress,\n                            duration_seconds: progressData.duration,\n                            timestamp: new Date().toISOString()\n                        };\n                        localStorage.setItem(key, JSON.stringify(offlineData));\n                        console.log('ðŸ“± Saved to localStorage after exception');\n                    } catch (storageError) {\n                        console.error('ðŸ’” All save mechanisms failed:', storageError);\n                    }\n                }\n            } else {\n                console.log('âš ï¸ Progress update ignored (insufficient data):', {\n                    hasProgressData: !!progressData,\n                    progress: progressData?.progress,\n                    duration: progressData?.duration,\n                    meetsThreshold: progressData?.progress >= 0 && progressData?.duration > 0\n                });\n            }\n        };\n\n        let progressHandler;\n        let messageListener;\n\n        if (isDirectSource) {\n            // Handle direct video sources (like MP4 files)\n            const videoElement = videoRef.current;\n            if (!videoElement) return;\n\n            const handleLoadedMetadata = async () => {\n                // Optimize video for iOS\n                if (isIOS()) {\n                    optimizeVideoForIOS(videoElement);\n                }\n\n                const history = await getWatchProgressForMedia(userId, id, type, currentSeason, currentEpisode);\n                if (history && history.progress_seconds) {\n                    videoElement.currentTime = history.progress_seconds;\n                }\n            };\n\n            const handleTimeUpdate = async () => {\n                if (videoElement.currentTime > 0) {\n                    const now = Date.now();\n                    if (now - lastProgressSaveTime.current < 2000) { // Increased to 2-second throttle\n                        return;\n                    }\n\n                    // Clear any pending save to prevent duplicate calls\n                    if (pendingSaveTimeout.current) {\n                        clearTimeout(pendingSaveTimeout.current);\n                    }\n\n                    lastProgressSaveTime.current = now;\n\n                    const progressData = {\n                        progress: Math.round(videoElement.currentTime),\n                        duration: Math.round(videoElement.duration),\n                        percentage: videoElement.duration > 0 ? (videoElement.currentTime / videoElement.duration) * 100 : 0\n                    };\n\n                    console.log(`ðŸŽ¬ Direct video - saving progress:`, progressData);\n\n                    const saveResult = await saveWatchProgress(\n                        userId,\n                        { ...mediaDetails, id: mediaDetails.id, type, season: currentSeason, episode: currentEpisode },\n                        progressData.progress,\n                        progressData.duration,\n                        false, // forceHistoryEntry\n                        session // Pass session from Auth context\n                    );\n\n                    if (saveResult) {\n                        console.log('âœ… Direct video progress saved successfully');\n\n                        // Use the actual saved progress data if available, otherwise fall back to local data\n                        const progressToUse = (typeof saveResult === 'object' && saveResult.progress_seconds !== undefined)\n                            ? saveResult\n                            : {\n                                progress_seconds: progressData.progress,\n                                duration_seconds: progressData.duration\n                            };\n\n                        console.log('ðŸ“Š Using direct video progress data for state update:', progressToUse);\n\n                        // Update state in real-time\n                        if (type === 'movie') {\n                            setMovieProgress(progressToUse);\n                        } else if (type === 'tv' || type === 'anime') {\n                            setSeriesWatchHistory(prevHistory => {\n                                const historyCopy = [...prevHistory];\n                                const index = historyCopy.findIndex(\n                                    h => h.season_number === currentSeason && h.episode_number === currentEpisode\n                                );\n\n                                const newProgressData = {\n                                    media_id: parseInt(id, 10),\n                                    media_type: type,\n                                    season_number: currentSeason,\n                                    episode_number: currentEpisode,\n                                    progress_seconds: progressToUse.progress_seconds,\n                                    duration_seconds: progressToUse.duration_seconds,\n                                };\n\n                                if (index > -1) {\n                                    historyCopy[index] = { ...historyCopy[index], ...newProgressData };\n                                } else {\n                                    historyCopy.push(newProgressData);\n                                }\n\n                                return historyCopy;\n                            });\n                        }\n                    } else {\n                        console.error('âŒ Failed to save direct video progress');\n                    }\n\n                    // Removed next episode prompt logic - Videasy handles autoplay automatically\n                    const timeRemaining = progressData.duration - progressData.progress;\n                    // Videasy will handle next episode prompts automatically\n                }\n            };\n\n            videoElement.addEventListener('loadedmetadata', handleLoadedMetadata);\n            videoElement.addEventListener('timeupdate', handleTimeUpdate);\n\n            return () => {\n                videoElement.removeEventListener('loadedmetadata', handleLoadedMetadata);\n                videoElement.removeEventListener('timeupdate', handleTimeUpdate);\n            };\n        } else {\n            messageListener = (event) => {\n                const trustedDomains = ['player.videasy.net', 'vidsrc.to', 'embed.su', 'vidsrc.xyz', 'vidsrc.in', 'vidsrc.pm'];\n                const origin = new URL(event.origin);\n\n                if (!trustedDomains.includes(origin.hostname)) {\n                    return;\n                }\n\n                try {\n                    // Attempt to parse the data if it's a string, otherwise use it directly\n                    const data = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;\n\n                    // New: Efficient `PROGRESS_UPDATE` format from Videasy/other players\n                    if (data && data.type === 'PROGRESS_UPDATE' && data.data) {\n                        const progressData = {\n                            progress: data.data.progress?.watched,\n                            duration: data.data.progress?.duration,\n                            // Ensure season/episode from the message are used if available\n                            season: data.data.season || currentSeason,\n                            episode: data.data.episode || currentEpisode\n                        };\n                        handleProgressUpdate(progressData, 'PROGRESS_UPDATE');\n                        return; // Exit after handling\n                    }\n\n                    // Deprecated: Legacy `MEDIA_DATA` format for backward compatibility\n                    if (data.type === 'MEDIA_DATA' && data.data) {\n\n                        let mediaData = data.data;\n                        if (typeof mediaData === 'string') {\n                            try {\n                                mediaData = JSON.parse(mediaData);\n                            } catch (e) {\n                                console.error('Error parsing double-encoded MEDIA_DATA string:', e);\n                                return;\n                            }\n                        }\n\n                        // The data can be an object keyed by `tv-id`.\n                        const mediaKey = `${type}-${id}`;\n                        const media = mediaData[mediaKey];\n\n                        if (media && media.progress) {\n                            const normalizedProgress = {\n                                progress: media.progress.watched,\n                                duration: media.progress.duration,\n                                season: media.last_season_watched,\n                                episode: media.last_episode_watched,\n                            };\n                            handleProgressUpdate(normalizedProgress, 'MEDIA_DATA');\n                        }\n                        return; // Exit after handling\n                    }\n\n                    // Generic event handling for other player messages\n                    if (data.type === 'PLAYER_EVENT' && data.data) {\n                        if (data.data.event === 'timeupdate') {\n                            const progressData = {\n                                progress: data.data.time,\n                                duration: data.data.duration\n                            };\n                            if (progressData.progress && progressData.duration) {\n                                handleProgressUpdate(progressData, 'PLAYER_EVENT');\n                            }\n                        } else if (data.data.event === 'ended' && (type === 'tv' || type === 'anime')) {\n                            console.log('Player reported \"ended\" event - Videasy will handle next episode automatically.');\n                            // Removed handleNextEpisode() - Videasy handles this automatically\n                        } else if (data.data.event === 'player_ready') {\n                            console.log('Player is ready.');\n                            setPlayerReady(true);\n                        }\n                    }\n\n                } catch (error) {\n                    // This will catch JSON parsing errors or other exceptions\n                    console.error(\"Error processing message from player:\", {\n                        origin: event.origin,\n                        data: event.data,\n                        error: error.message\n                    });\n                }\n            };\n\n            window.addEventListener('message', messageListener);\n\n            // Fallback for players that don't send `player_ready` has been moved\n            // to a dedicated useEffect hook that depends on streamUrl.\n\n            return () => {\n                window.removeEventListener('message', messageListener);\n                if (progressHandler) clearInterval(progressHandler);\n                if (pendingSaveTimeout.current) clearTimeout(pendingSaveTimeout.current);\n            };\n        }\n    }, [mediaDetails, isDirectSource, videoRef, currentSeason, currentEpisode, userId]);\n\n    // This effect specifically handles the player ready timeout logic.\n    // It only runs when a stream URL for an iframe is present.\n    useEffect(() => {\n        if (streamUrl && !isDirectSource && !playerReady) {\n            const readyTimeout = setTimeout(() => {\n                // Re-check playerReady state inside timeout to avoid race conditions\n                if (!playerReady) {\n                    console.warn('Player ready timeout, starting fallback progress tracking.');\n                    startFallbackTracking();\n                }\n            }, 10000); // Increased timeout to 10 seconds for better reliability\n\n            return () => clearTimeout(readyTimeout);\n        }\n    }, [streamUrl, isDirectSource, playerReady]);\n\n    const startFallbackTracking = () => {\n        // Fallback progress tracking if player doesn't post messages\n        // This is a failsafe and should ideally not be relied upon\n        const progressHandler = setInterval(() => {\n            if (document.hasFocus()) {\n                console.log('Fallback: Checking for progress...');\n                // You would need a way to get progress from the iframe if possible,\n                // but cross-origin restrictions make this very difficult.\n                // This is a placeholder for a potential future implementation.\n            }\n        }, 15000);\n\n        return () => clearInterval(progressHandler);\n    };\n\n    useEffect(() => {\n        // Reset timeout error when streamUrl or error changes\n        setStreamTimeoutError(false);\n        if (!streamUrl && !streamError) {\n            streamTimeoutRef.current = setTimeout(() => {\n                setStreamTimeoutError(true);\n                console.log('Stream timeout error');\n            }, 25000); // 25 seconds\n        }\n        return () => {\n            if (streamTimeoutRef.current) clearTimeout(streamTimeoutRef.current);\n        };\n    }, [streamUrl, streamError, currentSeason, currentEpisode, currentSource]);\n\n    if (error) {\n        return (\n            <div class=\"container\" style={{ textAlign: 'center', marginTop: '50px' }}>\n                <div class=\"error-state\">\n                    <h2>An Error Occurred</h2>\n                    <p>{error}</p>\n                    <button onClick={() => route('/')} class=\"btn btn-primary\">Go Home</button>\n                </div>\n            </div>\n        );\n    }\n\n    if (loading) {\n        return (\n            <div class=\"loading-state\">\n                <div class=\"loading-spinner\"></div>\n                <p>Loading media details...</p>\n                <p>If your video doesnt load refresh the page or pick a new server.</p>\n\n            </div>\n        );\n    }\n\n    if (!mediaDetails) {\n        return (\n            <div class=\"container\">\n                <div class=\"error-state\">\n                    <h2>Unable to Load Media</h2>\n                    <p>We couldn't load the details for this content. This could be due to:</p>\n                    <ul>\n                        <li>Network connectivity issues</li>\n                        <li>The content may no longer be available</li>\n                        <li>Server maintenance</li>\n                    </ul>\n                    <button\n                        onClick={() => window.location.reload()}\n                        class=\"btn btn-primary\"\n                        style={{ marginTop: '20px' }}\n                    >\n                        Try Again\n                    </button>\n                </div>\n            </div>\n        );\n    }\n\n    const { title, name, overview, vote_average, release_date, first_air_date, last_air_date, runtime, number_of_seasons, genres, poster_path, status } = mediaDetails;\n\n    // Use AniList ID for anime, TMDB ID for others, and the correct type from props\n    const favoritedId = type === 'anime' ? id : mediaDetails.id;\n    const favorited = isShowFavorited(favoritedId, type);\n\n    const year = release_date || first_air_date ? new Date(release_date || first_air_date).getFullYear() : '';\n\n    const handleFavoriteClick = () => {\n        // Ensure the correct ID (AniList for anime) and type are passed for both add and remove\n        const itemToFavorite = { ...mediaDetails, id: favoritedId, type: type };\n        if (favorited) {\n            removeFavoriteShow(itemToFavorite);\n        } else {\n            addFavoriteShow(itemToFavorite);\n        }\n    };\n\n    // Manual PiP Trigger\n    const handlePiPClick = async () => {\n        const iframe = document.querySelector('iframe[title=\"Video Player\"]');\n        const video = document.querySelector('video');\n        const element = isDirectSource ? video : iframe;\n\n        if (element && playerContainerRef.current && mediaDetails) {\n            const videoInfo = {\n                title: mediaDetails.title || mediaDetails.name || 'Video',\n                url: window.location.href,\n                type: type,\n                id: id,\n                season: currentSeason,\n                episode: currentEpisode\n            };\n\n            if (isMiniPlayerActive) {\n                closeMiniPlayer();\n            } else {\n                await openMiniPlayer(element, playerContainerRef.current, videoInfo);\n            }\n        }\n    };\n\n    return (\n        <div>\n            <Helmet>\n                <title>{title || name} - Fovi</title>\n            </Helmet>\n\n            {showTrailer && (\n                <div className=\"trailer-modal\" onClick={() => setShowTrailer(false)}>\n                    <div className=\"trailer-content\" onClick={(e) => e.stopPropagation()}>\n                        <span className=\"close-trailer\" onClick={() => setShowTrailer(false)}>&times;</span>\n                        <iframe\n                            src={`https://www.youtube.com/embed/${videos.find(v => v.type === 'Trailer')?.key}?autoplay=1`}\n                            frameBorder=\"0\"\n                            allow=\"autoplay; encrypted-media; fullscreen\"\n                            allowFullScreen\n                            title=\"Trailer\"\n                        ></iframe>\n                    </div>\n                </div>\n            )}\n\n            <div class=\"player-container\" ref={playerContainerRef}>\n                {!streamUrl && streamError && (\n                    <div class=\"stream-error-message\">\n                        <p>{streamError.message}</p>\n                        {streamError.canRetry && (\n                            <div class=\"error-actions\">\n                                <button\n                                    onClick={async () => {\n                                        setIsRetrying(true);\n                                        // Wait a bit then retry\n                                        setTimeout(() => {\n                                            const fetchStreamUrl = async () => {\n                                                const url = `${API_BASE_URL}/stream-url?type=${type}&id=${id}&source=${currentSource}${(type === 'tv' || type === 'anime') ? `&season=${currentSeason}&episode=${currentEpisode}` : ''}${type === 'anime' ? `&dub=${isDubbed}` : ''}`;\n\n                                                try {\n                                                    const response = await fetch(url);\n                                                    const streamUrlData = await response.json();\n\n                                                    if (response.ok) {\n                                                        setStreamUrl(streamUrlData.url);\n                                                        setIsDirectSource(streamUrlData.isDirectSource);\n                                                        setQualities(streamUrlData.qualities || []);\n                                                        setStreamError(null);\n                                                    } else {\n                                                        throw new Error(streamUrlData.message);\n                                                    }\n                                                } catch (error) {\n                                                    console.error('Retry failed:', error);\n                                                    setStreamError({\n                                                        message: \"Retry failed. Please try selecting a different source.\",\n                                                        canRetry: true\n                                                    });\n                                                }\n                                                setIsRetrying(false);\n                                            };\n                                            fetchStreamUrl();\n                                        }, 1000);\n                                    }}\n                                    disabled={isRetrying}\n                                    class=\"btn retry-btn\"\n                                >\n                                    {isRetrying ? 'Retrying...' : 'Retry'}\n                                </button>\n                                <p>Or try selecting a different source from the list below.</p>\n                            </div>\n                        )}\n                    </div>\n                )}\n                {!streamUrl && !streamError && !streamTimeoutError && (\n                    <div class=\"stream-loading\">\n                        <p>Loading video stream... </p>\n                        <p>If your video doesnt load refresh the page or pick a new server.</p>\n                    </div>\n                )}\n                {/* PATCH: Show error if stream never loads */}\n                {!streamUrl && !streamError && streamTimeoutError && (\n                    <div class=\"stream-error-message\">\n                        <p>Sorry, this episode failed to load. Please refresh the page.</p>\n                        <div class=\"error-actions\">\n                            <button\n                                onClick={() => window.location.reload()}\n                                class=\"btn retry-btn\"\n                            >\n                                Refresh\n                            </button>\n                            <p>Or try selecting a different source from the list below if refreshing doesn't work.</p>\n                        </div>\n                    </div>\n                )}\n                {isDirectSource ? (\n                    <video\n                        ref={videoRef}\n                        src={streamUrl}\n                        controls\n                        autoPlay\n                        playsInline\n                        preload=\"metadata\"\n                        width=\"100%\"\n                        style={{ maxWidth: '100%', height: 'auto' }}\n                        x-webkit-airplay=\"allow\"\n                        webkit-playsinline=\"true\"\n                    ></video>\n                ) : (\n                    streamUrl && (\n                        <iframe\n                            src={streamUrl}\n                            width=\"100%\"\n                            height=\"100%\"\n                            style={{ position: 'absolute', top: 0, left: 0, width: '100%', height: '100%' }}\n                            frameBorder=\"0\"\n                            allowFullScreen\n                            allow=\"autoplay; fullscreen; picture-in-picture; encrypted-media; accelerometer; gyroscope; web-share\"\n                            title=\"Video Player\"\n                            loading=\"eager\"\n                            referrerPolicy=\"no-referrer-when-downgrade\"\n                            importance=\"high\"\n                            onLoad={() => {\n                                console.log('ðŸŽ¬ Player iframe loaded');\n                                setPlayerReady(true);\n\n                                // Handle progress restoration via postMessage (only for non-Videasy sources)\n                                // Videasy handles progress natively via URL parameters for faster loading\n                                if (currentSource !== 'videasy' && progressToResume > 30) {\n                                    setTimeout(() => {\n                                        const iframe = document.querySelector('iframe');\n                                        if (iframe && iframe.contentWindow) {\n                                            try {\n                                                iframe.contentWindow.postMessage({\n                                                    type: 'SEEK_TO',\n                                                    time: progressToResume\n                                                }, '*');\n                                                console.log(`ðŸ“ Sent seek command to restore progress: ${progressToResume}s`);\n                                            } catch (e) {\n                                                console.log('Could not send seek command:', e);\n                                            }\n                                        }\n                                    }, 500); // Reduced to 500ms for faster response\n                                } else if (currentSource === 'videasy') {\n                                    console.log('ðŸ“ Videasy native resume - no seeking needed');\n                                } else {\n                                    console.log('ðŸ“ No significant progress to resume, starting from beginning');\n                                }\n                            }}\n                        ></iframe>\n                    )\n                )}\n                {/* Removed next episode prompt UI - Videasy handles this automatically */}\n            </div>\n            <div class=\"container\">\n                <div class=\"media-details-layout\">\n                    <div class=\"poster\">\n                        <img src={getProxiedImageUrl(poster_path ? `${IMAGE_BASE_URL}${poster_path}` : 'https://via.placeholder.com/500x750.png?text=No+Image')} alt={title || name} />\n                        {movieProgressPercent > 0 && (\n                            <div class=\"movie-progress-container\">\n                                <div class=\"movie-progress-bar\">\n                                    <div\n                                        class=\"movie-progress\"\n                                        style={{ width: `${Math.max(2, movieProgressPercent)}%` }}\n                                    ></div>\n                                </div>\n                                <div class=\"movie-progress-text\">\n                                    {movieProgress.duration_seconds > 0\n                                        ? `${Math.floor(movieProgress.progress_seconds / 60)}m / ${Math.floor(movieProgress.duration_seconds / 60)}m watched`\n                                        : `${Math.floor(movieProgress.progress_seconds / 60)}m watched`\n                                    }\n                                </div>\n                            </div>\n                        )}\n                    </div>\n                    <div class=\"details\">\n                        <div class=\"title-container\">\n                            <h1>{title || name}</h1>\n                            <button\n                                onClick={handleFavoriteClick}\n                                class={`favorite-btn ${favorited ? 'favorited' : ''}`}\n                                disabled={!favoritesFetched}\n                            >\n                                {favoritesFetched ? (favorited ? 'â™¥ Favorited' : 'â™¡ Favorite') : '...'}\n                            </button>\n                            <button\n                                onClick={handleTrailerClick}\n                                class=\"favorite-btn trailer-btn\"\n                            >\n                                <i class=\"fas fa-film\"></i> Trailer\n                            </button>\n                            {isMiniPlayerSupported && (\n                                <button\n                                    onClick={handlePiPClick}\n                                    class={`favorite-btn pip-btn ${isMiniPlayerActive ? 'active' : ''}`}\n                                    title={isMiniPlayerActive ? \"Close Mini Player\" : \"Open Mini Player\"}\n                                >\n                                    <i class=\"fas fa-compress-alt\"></i> {isMiniPlayerActive ? 'Close PiP' : 'Mini Player'}\n                                </button>\n                            )}\n                            {!user && (\n                                <span class=\"login-hint\">\n                                    <small>\n                                        <a href=\"/login\" style={{ color: '#007bff', textDecoration: 'none' }}>\n                                            Log in\n                                        </a> to save favorites, track progress & continue watching\n                                    </small>\n                                </span>\n                            )}\n                        </div>\n                        <div class=\"meta\">\n                            <span class=\"rating\">â˜… {mediaDetails.vote_average ? mediaDetails.vote_average.toFixed(1) : 'N/A'}</span>\n                            {(type === 'tv' || type === 'anime') && first_air_date && (\n                                <span style={{ marginLeft: 8 }}>\n                                    {(() => {\n                                        const startYear = first_air_date ? new Date(first_air_date).getFullYear() : null;\n                                        let endYear = null;\n                                        if (last_air_date) {\n                                            endYear = new Date(last_air_date).getFullYear();\n                                        } else if (status && status.toLowerCase() === 'ended') {\n                                            endYear = startYear;\n                                        }\n                                        if (startYear && endYear && startYear === endYear) {\n                                            return `${startYear}`;\n                                        } else if (startYear && endYear && endYear !== startYear) {\n                                            return `${startYear} - ${endYear}`;\n                                        } else if (startYear) {\n                                            return `${startYear} -`;\n                                        }\n                                        return '';\n                                    })()}\n                                </span>\n                            )}\n\n                            {runtime && <span>{runtime} min</span>}\n                            {number_of_seasons && <span>{number_of_seasons} Seasons</span>}\n                        </div>\n                        <div class=\"genres\">\n                            {genres && genres.map(g => <span class=\"genre-tag\">{g.name}</span>)}\n                        </div>\n                        <p class=\"overview\">{overview}</p>\n                        {qualities.length > 0 && (\n                            <div class=\"quality-selector\">\n                                <label>Quality:</label>\n                                {qualities.map(q => (\n                                    <button\n                                        class={`quality-btn ${streamUrl === q.url ? 'active' : ''}`}\n                                        onClick={() => setStreamUrl(q.url)}\n                                    >\n                                        {q.quality}p\n                                    </button>\n                                ))}\n                            </div>\n                        )}\n                    </div>\n                </div>\n\n                {type === 'anime' && (\n                    <div class=\"select-container\">\n                        <label for=\"dub-select\">Audio:</label>\n                        <select\n                            id=\"dub-select\"\n                            value={isDubbed}\n                            onChange={(e) => setIsDubbed(e.target.value === 'true')}\n                        >\n                            <option value=\"false\">Subbed</option>\n                            <option value=\"true\">Dubbed</option>\n                        </select>\n                    </div>\n                )}\n\n                <div class=\"selectors-container\">\n                    {(type === 'tv' || type === 'anime') && mediaDetails && mediaDetails.seasons && (\n                        <div class=\"select-container\">\n                            <label>Season:</label>\n                            <div class=\"selector-buttons\">\n                                {mediaDetails.seasons\n                                    .filter(s => s.season_number > 0)\n                                    .map(s => (\n                                        <button\n                                            key={s.id}\n                                            class={`selector-btn ${currentSeason === s.season_number ? 'active' : ''}`}\n                                            onClick={() => {\n                                                console.log(`ðŸŽ¯ User manually selected season ${s.season_number}`);\n                                                userNavigatedRef.current = true;\n                                                ignoredLegacyNavigation.current = null; // Reset ignored navigation log\n                                                const newUrl = `/watch/${type}/${id}/season/${s.season_number}/episode/1`;\n                                                route(newUrl, true);\n                                            }}\n                                        >\n                                            {s.name}\n                                        </button>\n                                    ))}\n                            </div>\n                        </div>\n                    )}\n                    {availableSources.length > 1 && (\n                        <div class=\"select-container\">\n                            <label>Source:</label>\n                            <div class=\"selector-buttons\">\n                                {availableSources.map(source => (\n                                    <button\n                                        key={source}\n                                        class={`selector-btn ${currentSource === source ? 'active' : ''}`}\n                                        onClick={() => setCurrentSource(source)}\n                                    >\n                                        {source}\n                                    </button>\n                                ))}\n                            </div>\n                        </div>\n                    )}\n                </div>\n\n                {(type === 'tv' || type === 'anime') && currentSeason !== null && currentEpisode !== null && (\n                    <div class=\"episodes-container\">\n                        <h3>Episodes</h3>\n                        {episodesLoading ? (\n                            <div class=\"loading-spinner\"></div>\n                        ) : (\n                            <>\n                                <div class=\"episode-list\">\n                                    {seasonDetails?.episodes\n                                        ?.slice((currentEpisodePage - 1) * episodesPerPage, currentEpisodePage * episodesPerPage)\n                                        ?.map(episode => {\n                                            // Find the progress for this specific episode from the array\n                                            const episodeHistory = seriesWatchHistory.find(\n                                                h => h.season_number === currentSeason && h.episode_number === episode.episode_number\n                                            );\n\n                                            // Calculate progress percentage with better error handling and fallback\n                                            const progressPercent = (() => {\n                                                if (episodeHistory && episodeHistory.progress_seconds > 0) {\n                                                    if (episodeHistory.duration_seconds && episodeHistory.duration_seconds > 0) {\n                                                        return Math.min(100, (episodeHistory.progress_seconds / episodeHistory.duration_seconds) * 100);\n                                                    }\n                                                    // Fallback for when duration is not available.\n                                                    // Show 5% for >30s, otherwise 2% to indicate some progress.\n                                                    return episodeHistory.progress_seconds > 30 ? 5 : 2;\n                                                }\n                                                return 0;\n                                            })();\n\n                                            // Debug logging for progress data\n                                            if (episodeHistory && episodeHistory.progress_seconds > 0) {\n                                                console.log(`ðŸ“Š Episode ${episode.episode_number} progress:`, {\n                                                    progress_seconds: episodeHistory.progress_seconds,\n                                                    duration_seconds: episodeHistory.duration_seconds,\n                                                    progressPercent: progressPercent\n                                                });\n                                            }\n\n                                            return (\n                                                <div\n                                                    key={episode.id}\n                                                    class={`episode-card ${episode.episode_number === currentEpisode ? 'active' : ''}`}\n                                                    onClick={() => {\n                                                        console.log(`ðŸŽ¯ User manually selected episode ${episode.episode_number}`);\n                                                        userNavigatedRef.current = true;\n                                                        ignoredLegacyNavigation.current = null; // Reset ignored navigation log\n                                                        const newUrl = `/watch/${type}/${id}/season/${currentSeason}/episode/${episode.episode_number}`;\n                                                        route(newUrl, true);\n                                                    }}\n                                                >\n                                                    <div class=\"episode-card-image\">\n                                                        <img src={getProxiedImageUrl(episode.still_path ? (episode.still_path.startsWith('/anilist_images/') || episode.still_path.startsWith('http') ? episode.still_path : `${IMAGE_BASE_URL}${episode.still_path}`) : `https://via.placeholder.com/300x169.png?text=${encodeURIComponent(episode.name)}`)} alt={episode.name} />\n                                                        <div class=\"episode-number-badge\">{episode.episode_number}</div>\n                                                        {progressPercent > 0 && (\n                                                            <div class=\"episode-progress-container\">\n                                                                <div class=\"episode-progress-bar\">\n                                                                    <div class=\"episode-progress\" style={{ width: `${Math.max(2, progressPercent)}%` }}></div>\n                                                                </div>\n                                                                <div class=\"episode-progress-text\">\n                                                                    {episodeHistory && episodeHistory.duration_seconds > 0\n                                                                        ? `${Math.floor(episodeHistory.progress_seconds / 60)}m / ${Math.floor(episodeHistory.duration_seconds / 60)}m`\n                                                                        : `${Math.floor(episodeHistory.progress_seconds / 60)}m watched`\n                                                                    }\n                                                                </div>\n                                                            </div>\n                                                        )}\n                                                    </div>\n                                                    <div class=\"episode-card-content\">\n                                                        <h4>\n                                                            {episode.name}\n                                                            {episode.air_date && (\n                                                                <span style={{ color: '#aaa', fontWeight: 400, fontSize: '0.95em', marginLeft: 8 }}>\n                                                                    {'â€¢ '}\n                                                                    {(() => {\n                                                                        const d = new Date(episode.air_date);\n                                                                        if (!isNaN(d)) {\n                                                                            return d.toLocaleDateString(undefined, { month: 'short', day: 'numeric', year: 'numeric' });\n                                                                        }\n                                                                        return null;\n                                                                    })()}\n                                                                </span>\n                                                            )}\n                                                        </h4>\n                                                        <p class=\"episode-overview\">{episode.overview}</p>\n                                                    </div>\n                                                </div>\n                                            );\n                                        })}\n                                </div>\n\n                                {/* Pagination Controls */}\n                                {seasonDetails?.episodes && seasonDetails.episodes.length > episodesPerPage && (() => {\n                                    const totalPages = Math.ceil(seasonDetails.episodes.length / episodesPerPage);\n                                    const pagesPerPagination = 10;\n                                    const totalPaginationPages = Math.ceil(totalPages / pagesPerPagination);\n                                    const startPage = (paginationPage - 1) * pagesPerPagination + 1;\n                                    const endPage = Math.min(startPage + pagesPerPagination - 1, totalPages);\n\n                                    const pageNumbers = Array.from({ length: (endPage - startPage + 1) }, (_, i) => startPage + i);\n\n                                    return (\n                                        <div class=\"pagination-controls\">\n                                            {paginationPage > 1 && <button onClick={() => setPaginationPage(p => p - 1)}><i class=\"fas fa-angle-double-left\"></i></button>}\n                                            {pageNumbers.map(number => (\n                                                <button\n                                                    key={number}\n                                                    class={currentEpisodePage === number ? 'active' : ''}\n                                                    onClick={() => setCurrentEpisodePage(number)}\n                                                >\n                                                    {number}\n                                                </button>\n                                            ))}\n                                            {paginationPage < totalPaginationPages && <button onClick={() => setPaginationPage(p => p + 1)}><i class=\"fas fa-angle-double-right\"></i></button>}\n                                        </div>\n                                    );\n                                })()}\n                            </>\n                        )}\n                    </div>\n                )}\n\n                {recommendations.length > 0 && (\n                    <div class=\"recommendations\">\n                        <h2>More Like This</h2>\n                        <div class=\"movie-grid\">\n                            {recommendations.map(item => (\n                                <MovieCard\n                                    key={`${item.media_type || type}-${item.id}`}\n                                    item={item}\n                                    type={type}\n                                    progress={null}\n                                    duration={null}\n                                />\n                            ))}\n                        </div>\n                    </div>\n                )}\n            </div>\n        </div>\n    );\n};\n\nexport default Watch;"],"names":["Watch","props","mediaDetails","setMediaDetails","useState","videos","setVideos","recommendations","setRecommendations","streamUrl","setStreamUrl","loading","setLoading","isPlaying","setIsPlaying","playerContainerRef","useRef","currentSeason","setCurrentSeason","currentEpisode","setCurrentEpisode","currentSource","setCurrentSource","availableSources","setAvailableSources","seasonDetails","setSeasonDetails","episodesLoading","setEpisodesLoading","isDubbed","setIsDubbed","streamError","setStreamError","isRetrying","setIsRetrying","streamTimeoutError","setStreamTimeoutError","streamTimeoutRef","error","setError","id","type","season","episode","tmdbId","setTmdbId","mediaType","setMediaType","showTrailer","setShowTrailer","isDirectSource","setIsDirectSource","qualities","setQualities","videoRef","seriesWatchHistory","setSeriesWatchHistory","movieProgress","setMovieProgress","playerReady","setPlayerReady","progressToResume","setProgressToResume","currentEpisodePage","setCurrentEpisodePage","paginationPage","setPaginationPage","initialPageSet","setInitialPageSet","episodesPerPage","sourceUpdatedFromBackend","previousEpisodeRef","userNavigatedRef","hasLoadedResumeData","isAutoNavigating","lastPlayerEventNavigation","playerEventModeEnabled","navigationTimeouts","lastPlayerEventTime","ignoredLegacyNavigation","lastProgressSaveTime","pendingSaveTimeout","currentProgressRef","user","session","useAuth","userId","tmdbType","openMiniPlayer","closeMiniPlayer","isMiniPlayerActive","isMiniPlayerSupported","useMiniPlayer","useEffect","supabase","setCurrentMediaItem","favoritesFetched","fetchContinueWatching","isShowFavorited","useStore","newSeason","newEpisode","movieProgressPercent","useMemo","calculateInitialEpisodePage","useCallback","targetEpisode","totalEpisodes","page","userIdRef","handleTrailerClick","video","timeout","handleFullscreenChange","delay","index","syncOfflineProgress","result","captureRefs","iframe","container","hasVideo","videoInfo","err","route","controller","timeoutId","anilistId","detailsUrl","API_BASE_URL","videosUrl","recommendationsUrl","fetchData","url","errorMessage","res","data","detailsData","videosData","recommendationsData","lastWatchedWithProgress","getLastWatchedEpisodeWithProgress","newUrl","history","getSeriesHistory","progressData","getWatchProgressForMedia","mediaIdForRequest","response","currentEpisodeKey","episodeChanged","streamId","isAnimeMovie","currentUserId","handleProgressUpdate","messageType","seasonToSave","episodeToSave","now","saveResult","saveWatchProgress","key","offlineData","progressToUse","prevHistory","historyCopy","h","newProgressData","storageError","messageListener","videoElement","handleLoadedMetadata","isIOS","optimizeVideoForIOS","handleTimeUpdate","event","trustedDomains","origin","mediaData","e","mediaKey","media","normalizedProgress","readyTimeout","startFallbackTracking","progressHandler","jsx","jsxs","title","name","overview","vote_average","release_date","first_air_date","last_air_date","runtime","number_of_seasons","genres","poster_path","status","favoritedId","favorited","handleFavoriteClick","itemToFavorite","removeFavoriteShow","addFavoriteShow","handlePiPClick","element","Helmet","v","streamUrlData","getProxiedImageUrl","IMAGE_BASE_URL","startYear","endYear","g","q","source","Fragment","episodeHistory","progressPercent","d","totalPages","pagesPerPagination","totalPaginationPages","startPage","endPage","pageNumbers","_","i","p","number","item","MovieCard"],"mappings":"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"}