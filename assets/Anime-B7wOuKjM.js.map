{"version":3,"file":"Anime-B7wOuKjM.js","sources":["../../src/components/AnimeCard.jsx","../../src/pages/Anime.jsx"],"sourcesContent":["import { h } from 'preact';\nimport { useState, useCallback, useEffect, useRef } from 'preact/hooks';\nimport { route } from 'preact-router';\nimport { useStore } from '../store';\nimport { useAuth } from '../context/Auth';\nimport './AnimeCard.css';\nimport { getProxiedImageUrl } from '../config';\n\nconst AnimeCard = ({ item, progress, duration, showDeleteButton, onDelete, onClick }) => {\n    const [isVisible, setIsVisible] = useState(false);\n    const cardRef = useRef(null);\n    \n    // Intersection Observer for lazy loading high-quality images\n    useEffect(() => {\n        const observer = new IntersectionObserver(\n            ([entry]) => {\n                setIsVisible(entry.isIntersecting);\n            },\n            {\n                rootMargin: '50px',\n                threshold: 0.1\n            }\n        );\n\n        if (cardRef.current) {\n            observer.observe(cardRef.current);\n        }\n\n        return () => {\n            if (cardRef.current) {\n                observer.unobserve(cardRef.current);\n            }\n        };\n    }, []);\n    \n    // Destructure anime-specific properties from AniList data\n    const {\n        id,\n        title,\n        poster_path,\n        overview,\n        vote_average,\n        first_air_date,\n        // Enhanced anime properties from AniList\n        status,\n        episodes,\n        format,\n        nextAiringEpisode,\n        studios,\n        genres,\n        season,\n        seasonYear,\n        source,\n        meanScore,\n        favourites,\n        tags,\n        trailer,\n        isAdult,\n        duration: episodeDuration,\n        // Continue watching properties\n        season_number,\n        episode_number,\n        episode_name\n    } = item;\n\n    const animeTitle = title?.english || title?.romaji || title || item.name || 'Unknown Anime';\n    \n    // Calculate progress percentage\n    const progressPercent = (progress && duration > 0) ? (progress / duration) * 100 : 0;\n\n    // Calculate year from release date\n    const year = first_air_date ? new Date(first_air_date).getFullYear() : seasonYear;\n\n    const { user } = useAuth();\n    const { addFavorite, removeFavorite, isShowFavorited, favoritesFetched } = useStore();\n    \n    const favorited = isShowFavorited(item.id || item.anilist_id, 'anime', item.season_number, item.episode_number);\n\n    const handleFavoriteClick = (e) => {\n        e.preventDefault();\n        e.stopPropagation();\n\n        if (!user) return;\n\n        if (favorited) {\n            removeFavorite(user.id, item.id || item.anilist_id, 'anime', item.season_number, item.episode_number);\n        } else {\n            addFavorite(user.id, { ...item, type: 'anime' });\n        }\n    };\n\n    // Enhanced click handler for anime with conditional routing\n    const handleCardClick = (e) => {\n        e.preventDefault();\n        e.stopPropagation();\n        \n        console.log('AnimeCard clicked:', item);\n        \n        if (onClick) {\n            onClick(item);\n        } else {\n            // Determine the correct routing based on source\n            let link;\n            \n            if (item.source === 'tmdb') {\n                // For TMDB content, route to the appropriate media type\n                const mediaType = item.media_type || 'tv'; // Default to TV for anime\n                const tmdbId = item.tmdb_id || item.id;\n                link = `/watch/${mediaType}/${tmdbId}`;\n                \n                // For TV shows, add season/episode\n                if (mediaType === 'tv') {\n                    if (item.season_number && item.episode_number) {\n                        link += `/season/${item.season_number}/episode/${item.episode_number}`;\n                    } else {\n                        link += `/season/1/episode/1`;\n                    }\n                }\n            } else {\n                // For AniList content, use anime route with AniList ID\n                const animeId = item.anilist_id || item.id;\n                link = `/watch/anime/${animeId}`;\n                \n                // Deep linking support for specific episodes\n                if (item.season_number && item.episode_number) {\n                    link += `/season/${item.season_number}/episode/${item.episode_number}`;\n                } else {\n                    // Default to season 1, episode 1 for anime\n                    link += `/season/1/episode/1`;\n                }\n            }\n            \n            // Get audio preference for routing (only for anime)\n            if (item.source !== 'tmdb' || item.media_type === 'tv') {\n                const audioPreference = localStorage.getItem('anime-audio-preference') || 'subbed';\n                const urlParams = new URLSearchParams();\n                if (audioPreference === 'dubbed') {\n                    urlParams.set('dub', 'true');\n                }\n                \n                if (urlParams.toString()) {\n                    link += `?${urlParams.toString()}`;\n                }\n            }\n            \n            console.log('Routing to:', link);\n            route(link);\n        }\n    };\n\n    // Enhanced subtitle text for anime with comprehensive metadata\n    const getSubtitleText = () => {\n        if (season_number && episode_number) {\n            // This is a specific episode (from continue watching)\n            return `S${season_number} E${episode_number}${episode_name ? `: ${episode_name}` : ''}`;\n        }\n        \n        // Build comprehensive subtitle for anime listing\n        const parts = [];\n        if (year) parts.push(year.toString());\n        if (episodes) parts.push(`${episodes} episodes`);\n        if (format && format !== 'TV') parts.push(format);\n        if (status === 'RELEASING') parts.push('Airing');\n        \n        return parts.length > 0 ? parts.join(' • ') : 'Anime';\n    };\n\n    const subtitleText = getSubtitleText();\n\n    // Get anime status badge with enhanced status mapping\n    const getStatusBadge = () => {\n        if (!status) return null;\n        \n        const statusMap = {\n            'RELEASING': { text: 'Airing', class: 'airing' },\n            'FINISHED': { text: 'Completed', class: 'completed' },\n            'NOT_YET_RELEASED': { text: 'Upcoming', class: 'upcoming' },\n            'CANCELLED': { text: 'Cancelled', class: 'cancelled' },\n            'HIATUS': { text: 'Hiatus', class: 'hiatus' }\n        };\n        \n        const statusInfo = statusMap[status];\n        if (!statusInfo) return null;\n        \n        return (\n            <div className={`anime-status-badge ${statusInfo.class}`}>\n                {statusInfo.text}\n            </div>\n        );\n    };\n\n    // Get next episode info for currently airing anime\n    const getNextEpisodeInfo = () => {\n        if (!nextAiringEpisode || status !== 'RELEASING') return null;\n        \n        const timeUntilAiring = nextAiringEpisode.timeUntilAiring;\n        if (timeUntilAiring <= 0) return null;\n        \n        const days = Math.floor(timeUntilAiring / (24 * 60 * 60));\n        const hours = Math.floor((timeUntilAiring % (24 * 60 * 60)) / (60 * 60));\n        const minutes = Math.floor((timeUntilAiring % (60 * 60)) / 60);\n        \n        let timeText = '';\n        if (days > 0) {\n            timeText = `${days}d ${hours}h`;\n        } else if (hours > 0) {\n            timeText = `${hours}h ${minutes}m`;\n        } else if (minutes > 0) {\n            timeText = `${minutes}m`;\n        } else {\n            timeText = 'Soon';\n        }\n        \n        return (\n            <div className=\"next-episode-info\">\n                <span className=\"next-ep-label\">Ep {nextAiringEpisode.episode}</span>\n                <span className=\"next-ep-time\">in {timeText}</span>\n            </div>\n        );\n    };\n\n    // Get studio information\n    const getStudioInfo = () => {\n        if (!studios || studios.length === 0) return null;\n        \n        // Find main studio or use first one\n        const mainStudio = studios.find(studio => studio.isMain) || studios[0];\n        return mainStudio?.name || mainStudio;\n    };\n\n    // Get genre tags (limit to 2 for space)\n    const getGenreTags = () => {\n        if (!genres || genres.length === 0) return null;\n        \n        return genres.slice(0, 2).map(genre => (\n            <span key={genre} className=\"genre-tag\">{genre}</span>\n        ));\n    };\n\n    // Enhanced image URL handling for AniList images with lazy loading\n    const getFullImageUrl = (path) => {\n        if (!path) {\n            return 'https://via.placeholder.com/500x750/1a1a1a/ffffff?text=No+Image';\n        }\n        \n        // For AniList images (which already have full URLs), send them directly to the image proxy\n        if (path.includes('anilist.co') || path.includes('anili.st') || path.includes('anilistcdn')) {\n            return getProxiedImageUrl(path);\n        }\n        \n        // For other full URLs, use the proxy directly\n        if (path.startsWith('http')) {\n            return getProxiedImageUrl(path);\n        }\n        \n        // For TMDB relative paths, add resolution based on visibility\n        if (path.startsWith('/')) {\n            const resolution = isVisible ? 'w500' : 'w200';\n            const IMAGE_BASE_URL = `https://image.tmdb.org/t/p/${resolution}`;\n            return getProxiedImageUrl(`${IMAGE_BASE_URL}${path}`);\n        }\n        \n        // For relative paths (TMDB), use the proxy with the base URL added\n        return getProxiedImageUrl(path);\n    };\n\n    // Get rating with enhanced scoring\n    const getRating = () => {\n        const score = meanScore || vote_average;\n        if (!score) return 'N/A';\n        \n        // Convert AniList score (0-100) to 0-10 scale if needed\n        const normalizedScore = score > 10 ? score / 10 : score;\n        return normalizedScore.toFixed(1);\n    };\n\n    return (\n        <div className=\"anime-card-container\" ref={cardRef}>\n            <div \n                className=\"anime-card\" \n                onClick={handleCardClick}\n                style={{ cursor: 'pointer' }}\n                role=\"button\"\n                tabIndex={0}\n                onKeyDown={(e) => {\n                    if (e.key === 'Enter' || e.key === ' ') {\n                        e.preventDefault();\n                        handleCardClick(e);\n                    }\n                }}\n            >\n                <div className=\"anime-poster-wrapper\">\n                    <img \n                        src={getFullImageUrl(poster_path)} \n                        alt={animeTitle} \n                        loading=\"lazy\" \n                        width=\"500\" \n                        height=\"750\"\n                    />\n                    \n                    {/* Enhanced gradient overlay */}\n                    <div className=\"anime-scrim\"></div>\n                    \n                    {/* Anime status badge */}\n                    {getStatusBadge()}\n                    \n                    {/* Progress bar for continue watching */}\n                    {progressPercent > 0.01 && (\n                        <div className=\"anime-progress-container\">\n                            <div className=\"anime-progress-bar\" style={{ width: `${Math.min(progressPercent, 100)}%` }}></div>\n                        </div>\n                    )}\n                    \n                    {/* Data source indicator */}\n                    <div className=\"streaming-indicator\">\n                        <span className={`source-badge ${(item.source || 'tmdb') === 'anilist' ? 'anilist' : 'tmdb'}`}>\n                            {(item.source || 'tmdb') === 'anilist' ? 'AniList' : 'TMDB'}\n                        </span>\n                    </div>\n                    \n                    <div className=\"anime-card-info\">\n                        {/* Title and favorite button */}\n                        <div className=\"anime-title-row\">\n                            <h3 className=\"anime-card-title\">{animeTitle}</h3>\n                            {user && (\n                                <button\n                                    className={`anime-favorite-btn ${favorited ? 'favorited' : ''}`}\n                                    onClick={handleFavoriteClick}\n                                    aria-label={favorited ? 'Remove from favorites' : 'Add to favorites'}\n                                    disabled={!favoritesFetched}\n                                >\n                                    ♥︎\n                                </button>\n                            )}\n                        </div>\n                        \n                        {/* Subtitle with episode/format info */}\n                        {subtitleText && (\n                            <p className=\"anime-card-subtitle\">{subtitleText}</p>\n                        )}\n                        \n                        {/* Next episode info for airing anime */}\n                        {getNextEpisodeInfo()}\n                        \n                        {/* Studio info */}\n                        {getStudioInfo() && (\n                            <p className=\"anime-studio-info\">\n                                {getStudioInfo()}\n                            </p>\n                        )}\n                        \n                        {/* Genre tags */}\n                        {genres && genres.length > 0 && (\n                            <div className=\"anime-genre-tags\">\n                                {getGenreTags()}\n                            </div>\n                        )}\n                        \n                        {/* Rating with AniList scoring */}\n                        <div className=\"anime-rating-row\">\n                            <span className=\"anime-rating\">★ {getRating()}</span>\n                            {favourites && (\n                                <span className=\"anime-favorites\">♥ {favourites.toLocaleString()}</span>\n                            )}\n                        </div>\n                    </div>\n                    \n                    {/* Delete button for continue watching */}\n                    {showDeleteButton && (\n                        <button\n                            className=\"anime-delete-btn\"\n                            onClick={(e) => {\n                                e.preventDefault();\n                                e.stopPropagation();\n                                if (onDelete) onDelete(item);\n                            }}\n                            aria-label=\"Remove from continue watching\"\n                        >\n                            &times;\n                        </button>\n                    )}\n                </div>\n            </div>\n        </div>\n    );\n};\n\nexport default AnimeCard;","import { h } from 'preact';\nimport { useState, useEffect, useCallback } from 'preact/hooks';\nimport { route } from 'preact-router';\nimport { useStore } from '../store';\nimport MovieCard from '../components/MovieCard';\nimport AnimeCard from '../components/AnimeCard';\nimport { getLastWatchedEpisodeWithProgress } from '../utils/watchHistory';\nimport { useAuth } from '../context/Auth';\nimport { API_BASE_URL } from '../config';\nimport LoadingSpinner from '../components/LoadingSpinner';\nimport './Home.css';\nimport './Anime.css';\n\nconst Anime = () => {\n    const [loading, setLoading] = useState(true);\n    const [trending, setTrending] = useState([]);\n    const [seasonal, setSeasonal] = useState([]);\n    const [popular, setPopular] = useState([]);\n    const [topRated, setTopRated] = useState([]);\n    const [error, setError] = useState(null);\n    const [videasyAvailable, setVideasyAvailable] = useState(true);\n\n    const { user } = useAuth();\n    const {\n        continueWatching,\n        continueWatchingFetched,\n        fetchContinueWatching\n    } = useStore();\n\n    useEffect(() => {\n        if (user && !continueWatchingFetched) {\n            fetchContinueWatching(user.id);\n        }\n    }, [user, continueWatchingFetched, fetchContinueWatching]);\n\n    const animeWatchHistory = continueWatching.filter(item => item.type === 'anime');\n\n    const fetchCombinedAnimeData = useCallback(async (retries = 3) => {\n\t    try {\n            const response = await fetch(`${API_BASE_URL}/trending/anime/combined`);\n\t        if (!response.ok) {\n                throw new Error(`API error: ${response.status}`);\n\t        }\n            return response.json();\n\t    } catch (error) {\n            console.error(`Error fetching combined anime data:`, error);\n\t        if (retries > 0) {\n\t            await new Promise(resolve => setTimeout(resolve, 1000 * (4 - retries)));\n                return fetchCombinedAnimeData(retries - 1);\n\t        }\n            return null; // Return null on failure\n\t    }\n\t}, []);\n\n\n    const handleAnimeClick = useCallback(async (animeItem) => {\n        // Determine the correct routing based on source\n        let mediaType, itemId, routePath;\n        \n        if (animeItem.source === 'tmdb') {\n            // For TMDB content, use the appropriate media type and TMDB ID\n            mediaType = animeItem.media_type || 'tv';\n            itemId = animeItem.tmdb_id || animeItem.id;\n            routePath = `/watch/${mediaType}/${itemId}`;\n            \n            // Only add season/episode for TV shows\n            if (mediaType === 'tv') {\n                if (user) {\n                    const nextEpisode = await getLastWatchedEpisodeWithProgress(user.id, itemId, mediaType);\n                    if (nextEpisode) {\n                        routePath += `/season/${nextEpisode.season}/episode/${nextEpisode.episode}`;\n                    } else {\n                        routePath += `/season/1/episode/1`;\n                    }\n                } else {\n                    routePath += `/season/1/episode/1`;\n                }\n            }\n        } else {\n            // For AniList content, use anime route with AniList ID\n            mediaType = 'anime';\n            itemId = animeItem.anilist_id || animeItem.id;\n            routePath = `/watch/anime/${itemId}`;\n            \n            if (user) {\n                const nextEpisode = await getLastWatchedEpisodeWithProgress(user.id, itemId, 'anime');\n                if (nextEpisode) {\n                    routePath += `/season/${nextEpisode.season}/episode/${nextEpisode.episode}`;\n                } else {\n                    routePath += `/season/1/episode/1`;\n                }\n            } else {\n                routePath += `/season/1/episode/1`;\n            }\n        }\n        \n        route(routePath);\n    }, [user]);\n\n    const checkServiceAvailability = useCallback(async () => {\n        try {\n            const videasyCheck = await fetch(`${API_BASE_URL}/health/videasy`, {\n                method: 'GET',\n                signal: AbortSignal.timeout(5000)\n            });\n            setVideasyAvailable(videasyCheck.ok);\n        } catch (error) {\n            console.warn('Videasy availability check failed:', error);\n            setVideasyAvailable(false);\n        }\n    }, []);\n\n    useEffect(() => {\n        checkServiceAvailability();\n    }, [checkServiceAvailability]);\n\n    useEffect(() => {\n        const fetchAllAnimeData = async () => {\n            setLoading(true);\n            setError(null);\n\n            try {\n                const combinedData = await fetchCombinedAnimeData();\n\n                if (combinedData) {\n                    // Filter out any items that don't have a poster\n                    const filterValidItems = (items) => items.filter(item => item.poster_path);\n\n                    setTrending(filterValidItems(combinedData.combined || []).slice(0, 20));\n                    setSeasonal(filterValidItems(combinedData.seasonal || []));\n\n                    // For popular and top-rated, we can sort the combined list\n                    const allAnime = filterValidItems(combinedData.combined || []);\n                    \n                    // Sort by popularity\n                    const popularAnime = [...allAnime].sort((a, b) => (b.popularity || 0) - (a.popularity || 0));\n                    setPopular(popularAnime.slice(0, 20)); // Take top 20 popular\n\n                    // Sort by vote average\n                    const topRatedAnime = [...allAnime].sort((a, b) => (b.vote_average || 0) - (a.vote_average || 0));\n                    setTopRated(topRatedAnime.slice(0, 20)); // Take top 20 rated\n                } else {\n                    throw new Error(\"Failed to fetch any anime data.\");\n                }\n\n            } catch (error) {\n                console.error('Error fetching anime data:', error);\n                setError('Failed to load anime data. Please refresh the page.');\n            } finally {\n                setLoading(false);\n            }\n        };\n\n        fetchAllAnimeData();\n    }, [fetchCombinedAnimeData]);\n\n    const renderSection = (title, items) => {\n        if (!items || items.length === 0) {\n            return null;\n        }\n        \n        return (\n            <section class=\"home-section\">\n                <h2>{title}</h2>\n                <div class=\"scrolling-row\">\n                    {items.map(item => (\n                        <AnimeCard\n                            key={`${title}-${item.id}`}\n                            item={item}\n                            onClick={() => handleAnimeClick(item)}\n                        />\n                    ))}\n                </div>\n            </section>\n        );\n    };\n\n    const ServiceStatusIndicator = () => (\n        <div class=\"service-status\">\n            <div class={`status-indicator ${videasyAvailable ? 'online' : 'offline'}`}>\n                <span class=\"status-dot\"></span>\n                Videasy: {videasyAvailable ? 'Online' : 'Offline'}\n            </div>\n        </div>\n    );\n\n    const ErrorDisplay = ({ error, onRetry }) => (\n        <div class=\"error-container\">\n            <div class=\"error-message\">\n                <h3>Something went wrong</h3>\n                <p>{error}</p>\n                <button onClick={onRetry} class=\"retry-button\">Try Again</button>\n            </div>\n            <ServiceStatusIndicator />\n        </div>\n    );\n\n    if (loading) {\n        return (\n            <div class=\"container home-page anime-page\">\n                <h1 class=\"main-title\">Anime</h1>\n                <ServiceStatusIndicator />\n                <LoadingSpinner text={'Loading anime...'} />\n            </div>\n        );\n    }\n\n    if (error) {\n        return (\n            <div class=\"container home-page anime-page\">\n                <h1 class=\"main-title\">Anime</h1>\n                <ErrorDisplay\n                    error={error}\n                    onRetry={() => {\n                        setError(null);\n                        checkServiceAvailability();\n                        // re-fetch data\n                    }}\n                />\n            </div>\n        );\n    }\n\n    return (\n        <div class=\"container home-page anime-page\">\n            <h1 class=\"main-title\">Anime</h1>\n            \n            <div class=\"anime-controls\">\n                <ServiceStatusIndicator />\n            </div>\n            \n            {animeWatchHistory.length > 0 && (\n                <section class=\"home-section\">\n                    <h2>Continue Watching</h2>\n                    <div class=\"scrolling-row scrolling-row--compact\">\n                        {animeWatchHistory.map(item => (\n                            <AnimeCard\n                                key={`continue-watching-${item.id}`}\n                                item={item}\n                                progress={item.progress_seconds}\n                                duration={item.duration_seconds}\n                                onClick={() => handleAnimeClick(item)}\n                            />\n                        ))}\n                    </div>\n                </section>\n            )}\n            \n            {renderSection('Trending Now', trending)}\n            {renderSection('This Season', seasonal)}\n            {renderSection('Popular Anime', popular)}\n            {renderSection('Top Rated Anime', topRated)}\n            \n            {!loading &&\n             trending.length === 0 &&\n             popular.length === 0 &&\n             topRated.length === 0 && (\n                <div class=\"no-content\">\n                    <h3>No anime content available</h3>\n                    <p>Please check your connection and try again.</p>\n                </div>\n            )}\n        </div>\n    );\n};\n\nexport default Anime;"],"names":["AnimeCard","item","progress","duration","showDeleteButton","onDelete","onClick","isVisible","setIsVisible","useState","cardRef","useRef","useEffect","observer","entry","id","title","poster_path","overview","vote_average","first_air_date","status","episodes","format","nextAiringEpisode","studios","genres","season","seasonYear","source","meanScore","favourites","tags","trailer","isAdult","episodeDuration","season_number","episode_number","episode_name","animeTitle","progressPercent","year","user","useAuth","addFavorite","removeFavorite","isShowFavorited","favoritesFetched","useStore","favorited","handleFavoriteClick","e","handleCardClick","link","mediaType","tmdbId","audioPreference","urlParams","route","subtitleText","parts","getStatusBadge","statusInfo","jsx","getNextEpisodeInfo","timeUntilAiring","days","hours","minutes","timeText","jsxs","getStudioInfo","mainStudio","studio","getGenreTags","genre","getFullImageUrl","path","getProxiedImageUrl","getRating","score","Anime","loading","setLoading","trending","setTrending","seasonal","setSeasonal","popular","setPopular","topRated","setTopRated","error","setError","videasyAvailable","setVideasyAvailable","continueWatching","continueWatchingFetched","fetchContinueWatching","animeWatchHistory","fetchCombinedAnimeData","useCallback","retries","response","API_BASE_URL","resolve","handleAnimeClick","animeItem","itemId","routePath","nextEpisode","getLastWatchedEpisodeWithProgress","checkServiceAvailability","videasyCheck","combinedData","filterValidItems","items","allAnime","popularAnime","a","b","topRatedAnime","renderSection","ServiceStatusIndicator","ErrorDisplay","onRetry","LoadingSpinner"],"mappings":"6NAQA,MAAMA,EAAY,CAAC,CAAE,KAAAC,EAAM,SAAAC,EAAU,SAAAC,EAAU,iBAAAC,EAAkB,SAAAC,EAAU,QAAAC,KAAc,CACrF,KAAM,CAACC,EAAWC,CAAY,EAAIC,EAAS,EAAK,EAC1CC,EAAUC,GAAO,IAAI,EAG3BC,EAAU,IAAM,CACZ,MAAMC,EAAW,IAAI,qBACjB,CAAC,CAACC,CAAK,IAAM,CACTN,EAAaM,EAAM,cAAc,CACrC,EACA,CACI,WAAY,OACZ,UAAW,EAAA,CACf,EAGJ,OAAIJ,EAAQ,SACRG,EAAS,QAAQH,EAAQ,OAAO,EAG7B,IAAM,CACLA,EAAQ,SACRG,EAAS,UAAUH,EAAQ,OAAO,CAE1C,CACJ,EAAG,CAAA,CAAE,EAGL,KAAM,CACF,GAAAK,EACA,MAAAC,EACA,YAAAC,EACA,SAAAC,EACA,aAAAC,EACA,eAAAC,EAEA,OAAAC,EACA,SAAAC,EACA,OAAAC,EACA,kBAAAC,EACA,QAAAC,EACA,OAAAC,EACA,OAAAC,EACA,WAAAC,EACA,OAAAC,EACA,UAAAC,EACA,WAAAC,EACA,KAAAC,EACA,QAAAC,EACA,QAAAC,EACA,SAAUC,EAEV,cAAAC,EACA,eAAAC,EACA,aAAAC,CAAA,EACArC,EAEEsC,EAAavB,GAAO,SAAWA,GAAO,QAAUA,GAASf,EAAK,MAAQ,gBAGtEuC,EAAmBtC,GAAYC,EAAW,EAAMD,EAAWC,EAAY,IAAM,EAG7EsC,EAAOrB,EAAiB,IAAI,KAAKA,CAAc,EAAE,cAAgBQ,EAEjE,CAAE,KAAAc,CAAA,EAASC,GAAA,EACX,CAAE,YAAAC,GAAa,eAAAC,GAAgB,gBAAAC,GAAiB,iBAAAC,EAAA,EAAqBC,GAAA,EAErEC,EAAYH,GAAgB7C,EAAK,IAAMA,EAAK,WAAY,QAASA,EAAK,cAAeA,EAAK,cAAc,EAExGiD,GAAuBC,GAAM,CAC/BA,EAAE,eAAA,EACFA,EAAE,gBAAA,EAEGT,IAEDO,EACAJ,GAAeH,EAAK,GAAIzC,EAAK,IAAMA,EAAK,WAAY,QAASA,EAAK,cAAeA,EAAK,cAAc,EAEpG2C,GAAYF,EAAK,GAAI,CAAE,GAAGzC,EAAM,KAAM,QAAS,EAEvD,EAGMmD,EAAmBD,GAAM,CAM3B,GALAA,EAAE,eAAA,EACFA,EAAE,gBAAA,EAEF,QAAQ,IAAI,qBAAsBlD,CAAI,EAElCK,EACAA,EAAQL,CAAI,MACT,CAEH,IAAIoD,EAEJ,GAAIpD,EAAK,SAAW,OAAQ,CAExB,MAAMqD,EAAYrD,EAAK,YAAc,KAC/BsD,EAAStD,EAAK,SAAWA,EAAK,GACpCoD,EAAO,UAAUC,CAAS,IAAIC,CAAM,GAGhCD,IAAc,OACVrD,EAAK,eAAiBA,EAAK,eAC3BoD,GAAQ,WAAWpD,EAAK,aAAa,YAAYA,EAAK,cAAc,GAEpEoD,GAAQ,sBAGpB,MAGIA,EAAO,gBADSpD,EAAK,YAAcA,EAAK,EACV,GAG1BA,EAAK,eAAiBA,EAAK,eAC3BoD,GAAQ,WAAWpD,EAAK,aAAa,YAAYA,EAAK,cAAc,GAGpEoD,GAAQ,sBAKhB,GAAIpD,EAAK,SAAW,QAAUA,EAAK,aAAe,KAAM,CACpD,MAAMuD,EAAkB,aAAa,QAAQ,wBAAwB,GAAK,SACpEC,EAAY,IAAI,gBAClBD,IAAoB,UACpBC,EAAU,IAAI,MAAO,MAAM,EAG3BA,EAAU,aACVJ,GAAQ,IAAII,EAAU,SAAA,CAAU,GAExC,CAEA,QAAQ,IAAI,cAAeJ,CAAI,EAC/BK,GAAML,CAAI,CACd,CACJ,EAmBMM,GAhBkB,IAAM,CAC1B,GAAIvB,GAAiBC,EAEjB,MAAO,IAAID,CAAa,KAAKC,CAAc,GAAGC,EAAe,KAAKA,CAAY,GAAK,EAAE,GAIzF,MAAMsB,EAAQ,CAAA,EACd,OAAInB,GAAMmB,EAAM,KAAKnB,EAAK,UAAU,EAChCnB,GAAUsC,EAAM,KAAK,GAAGtC,CAAQ,WAAW,EAC3CC,GAAUA,IAAW,MAAMqC,EAAM,KAAKrC,CAAM,EAC5CF,IAAW,aAAauC,EAAM,KAAK,QAAQ,EAExCA,EAAM,OAAS,EAAIA,EAAM,KAAK,KAAK,EAAI,OAClD,GAEqB,EAGfC,GAAiB,IAAM,CACzB,GAAI,CAACxC,EAAQ,OAAO,KAUpB,MAAMyC,EARY,CACd,UAAa,CAAE,KAAM,SAAU,MAAO,QAAA,EACtC,SAAY,CAAE,KAAM,YAAa,MAAO,WAAA,EACxC,iBAAoB,CAAE,KAAM,WAAY,MAAO,UAAA,EAC/C,UAAa,CAAE,KAAM,YAAa,MAAO,WAAA,EACzC,OAAU,CAAE,KAAM,SAAU,MAAO,QAAA,CAAS,EAGnBzC,CAAM,EACnC,OAAKyC,EAGDC,EAAC,OAAI,UAAW,sBAAsBD,EAAW,KAAK,GACjD,WAAW,IAAA,CAChB,EALoB,IAO5B,EAGME,GAAqB,IAAM,CAC7B,GAAI,CAACxC,GAAqBH,IAAW,YAAa,OAAO,KAEzD,MAAM4C,EAAkBzC,EAAkB,gBAC1C,GAAIyC,GAAmB,EAAG,OAAO,KAEjC,MAAMC,EAAO,KAAK,MAAMD,GAAmB,GAAK,GAAK,GAAG,EAClDE,EAAQ,KAAK,MAAOF,GAAmB,GAAK,GAAK,KAAQ,GAAK,GAAG,EACjEG,EAAU,KAAK,MAAOH,GAAmB,GAAK,IAAO,EAAE,EAE7D,IAAII,EAAW,GACf,OAAIH,EAAO,EACPG,EAAW,GAAGH,CAAI,KAAKC,CAAK,IACrBA,EAAQ,EACfE,EAAW,GAAGF,CAAK,KAAKC,CAAO,IACxBA,EAAU,EACjBC,EAAW,GAAGD,CAAO,IAErBC,EAAW,OAIXC,EAAC,MAAA,CAAI,UAAU,oBACX,SAAA,CAAAA,EAAC,OAAA,CAAK,UAAU,gBAAgB,SAAA,CAAA,MAAI9C,EAAkB,OAAA,EAAQ,EAC9D8C,EAAC,OAAA,CAAK,UAAU,eAAe,SAAA,CAAA,MAAID,CAAA,CAAA,CAAS,CAAA,EAChD,CAER,EAGME,EAAgB,IAAM,CACxB,GAAI,CAAC9C,GAAWA,EAAQ,SAAW,EAAG,OAAO,KAG7C,MAAM+C,EAAa/C,EAAQ,KAAKgD,GAAUA,EAAO,MAAM,GAAKhD,EAAQ,CAAC,EACrE,OAAO+C,GAAY,MAAQA,CAC/B,EAGME,GAAe,IACb,CAAChD,GAAUA,EAAO,SAAW,EAAU,KAEpCA,EAAO,MAAM,EAAG,CAAC,EAAE,IAAIiD,GAC1BZ,EAAC,OAAA,CAAiB,UAAU,YAAa,SAAAY,CAAA,EAA9BA,CAAoC,CAClD,EAICC,GAAmBC,GAChBA,EAKDA,EAAK,SAAS,YAAY,GAAKA,EAAK,SAAS,UAAU,GAAKA,EAAK,SAAS,YAAY,EAC/EC,EAAmBD,CAAI,EAI9BA,EAAK,WAAW,MAAM,EACfC,EAAmBD,CAAI,EAI9BA,EAAK,WAAW,GAAG,EAGZC,EAAmB,GADH,8BADJvE,EAAY,OAAS,MACuB,EACpB,GAAGsE,CAAI,EAAE,EAIjDC,EAAmBD,CAAI,EArBnB,kEAyBTE,GAAY,IAAM,CACpB,MAAMC,EAAQlD,GAAaX,EAC3B,OAAK6D,GAGmBA,EAAQ,GAAKA,EAAQ,GAAKA,GAC3B,QAAQ,CAAC,EAJb,KAKvB,EAEA,OACIjB,EAAC,MAAA,CAAI,UAAU,uBAAuB,IAAKrD,EACvC,SAAAqD,EAAC,MAAA,CACG,UAAU,aACV,QAASX,EACT,MAAO,CAAE,OAAQ,SAAA,EACjB,KAAK,SACL,SAAU,EACV,UAAYD,GAAM,EACVA,EAAE,MAAQ,SAAWA,EAAE,MAAQ,OAC/BA,EAAE,eAAA,EACFC,EAAgBD,CAAC,EAEzB,EAEA,SAAAmB,EAAC,MAAA,CAAI,UAAU,uBACX,SAAA,CAAAP,EAAC,MAAA,CACG,IAAKa,GAAgB3D,CAAW,EAChC,IAAKsB,EACL,QAAQ,OACR,MAAM,MACN,OAAO,KAAA,CAAA,EAIXwB,EAAC,MAAA,CAAI,UAAU,aAAA,CAAc,EAG5BF,GAAA,EAGArB,EAAkB,KACfuB,EAAC,MAAA,CAAI,UAAU,2BACX,SAAAA,EAAC,OAAI,UAAU,qBAAqB,MAAO,CAAE,MAAO,GAAG,KAAK,IAAIvB,EAAiB,GAAG,CAAC,GAAA,CAAI,CAAG,CAAA,CAChG,EAIJuB,EAAC,OAAI,UAAU,sBACX,WAAC,OAAA,CAAK,UAAW,iBAAiB9D,EAAK,QAAU,UAAY,UAAY,UAAY,MAAM,GACrF,UAAAA,EAAK,QAAU,UAAY,UAAY,UAAY,MAAA,CACzD,CAAA,CACJ,EAEAqE,EAAC,MAAA,CAAI,UAAU,kBAEX,SAAA,CAAAA,EAAC,MAAA,CAAI,UAAU,kBACX,SAAA,CAAAP,EAAC,KAAA,CAAG,UAAU,mBAAoB,SAAAxB,EAAW,EAC5CG,GACGqB,EAAC,SAAA,CACG,UAAW,sBAAsBd,EAAY,YAAc,EAAE,GAC7D,QAASC,GACT,aAAYD,EAAY,wBAA0B,mBAClD,SAAU,CAACF,GACd,SAAA,IAAA,CAAA,CAED,EAER,EAGCY,GACGI,EAAC,IAAA,CAAE,UAAU,sBAAuB,SAAAJ,EAAa,EAIpDK,GAAA,EAGAO,KACGR,EAAC,KAAE,UAAU,oBACR,aACL,EAIHrC,GAAUA,EAAO,OAAS,KACtB,MAAA,CAAI,UAAU,mBACV,SAAAgD,GAAA,CAAa,CAClB,EAIJJ,EAAC,MAAA,CAAI,UAAU,mBACX,SAAA,CAAAA,EAAC,OAAA,CAAK,UAAU,eAAe,SAAA,CAAA,KAAGS,GAAA,CAAU,EAAE,EAC7ChD,GACGuC,EAAC,OAAA,CAAK,UAAU,kBAAkB,SAAA,CAAA,KAAGvC,EAAW,eAAA,CAAe,CAAA,CAAE,CAAA,CAAA,CAEzE,CAAA,EACJ,EAGC3B,GACG2D,EAAC,SAAA,CACG,UAAU,mBACV,QAAUZ,GAAM,CACZA,EAAE,eAAA,EACFA,EAAE,gBAAA,EACE9C,KAAmBJ,CAAI,CAC/B,EACA,aAAW,gCACd,SAAA,GAAA,CAAA,CAED,CAAA,CAER,CAAA,CAAA,EAER,CAER,ECpXMgF,GAAQ,IAAM,CAChB,KAAM,CAACC,EAASC,CAAU,EAAI1E,EAAS,EAAI,EACrC,CAAC2E,EAAUC,CAAW,EAAI5E,EAAS,CAAA,CAAE,EACrC,CAAC6E,EAAUC,CAAW,EAAI9E,EAAS,CAAA,CAAE,EACrC,CAAC+E,EAASC,CAAU,EAAIhF,EAAS,CAAA,CAAE,EACnC,CAACiF,EAAUC,CAAW,EAAIlF,EAAS,CAAA,CAAE,EACrC,CAACmF,EAAOC,CAAQ,EAAIpF,EAAS,IAAI,EACjC,CAACqF,EAAkBC,CAAmB,EAAItF,EAAS,EAAI,EAEvD,CAAE,KAAAiC,CAAA,EAASC,GAAA,EACX,CACF,iBAAAqD,EACA,wBAAAC,EACA,sBAAAC,CAAA,EACAlD,GAAA,EAEJpC,EAAU,IAAM,CACR8B,GAAQ,CAACuD,GACTC,EAAsBxD,EAAK,EAAE,CAErC,EAAG,CAACA,EAAMuD,EAAyBC,CAAqB,CAAC,EAEzD,MAAMC,EAAoBH,EAAiB,OAAO/F,GAAQA,EAAK,OAAS,OAAO,EAEzEmG,EAAyBC,EAAY,MAAOC,EAAU,IAAM,CACjE,GAAI,CACG,MAAMC,EAAW,MAAM,MAAM,GAAGC,CAAY,0BAA0B,EACzE,GAAI,CAACD,EAAS,GACP,MAAM,IAAI,MAAM,cAAcA,EAAS,MAAM,EAAE,EAEnD,OAAOA,EAAS,KAAA,CACvB,OAASX,EAAO,CAEZ,OADG,QAAQ,MAAM,sCAAuCA,CAAK,EACzDU,EAAU,GACV,MAAM,IAAI,QAAQG,GAAW,WAAWA,EAAS,KAAQ,EAAIH,EAAQ,CAAC,EAC5DF,EAAuBE,EAAU,CAAC,GAEtC,IACd,CACJ,EAAG,CAAA,CAAE,EAGII,EAAmBL,EAAY,MAAOM,GAAc,CAEtD,IAAIrD,EAAWsD,EAAQC,EAEvB,GAAIF,EAAU,SAAW,QAOrB,GALArD,EAAYqD,EAAU,YAAc,KACpCC,EAASD,EAAU,SAAWA,EAAU,GACxCE,EAAY,UAAUvD,CAAS,IAAIsD,CAAM,GAGrCtD,IAAc,KACd,GAAIZ,EAAM,CACN,MAAMoE,EAAc,MAAMC,EAAkCrE,EAAK,GAAIkE,CAAiB,EAClFE,EACAD,GAAa,WAAWC,EAAY,MAAM,YAAYA,EAAY,OAAO,GAEzED,GAAa,qBAErB,MACIA,GAAa,8BAKrBvD,EAAY,QACZsD,EAASD,EAAU,YAAcA,EAAU,GAC3CE,EAAY,gBAAgBD,CAAM,GAE9BlE,EAAM,CACN,MAAMoE,EAAc,MAAMC,EAAkCrE,EAAK,GAAIkE,CAAe,EAChFE,EACAD,GAAa,WAAWC,EAAY,MAAM,YAAYA,EAAY,OAAO,GAEzED,GAAa,qBAErB,MACIA,GAAa,sBAIrBnD,GAAMmD,CAAS,CACnB,EAAG,CAACnE,CAAI,CAAC,EAEHsE,EAA2BX,EAAY,SAAY,CACrD,GAAI,CACA,MAAMY,EAAe,MAAM,MAAM,GAAGT,CAAY,kBAAmB,CAC/D,OAAQ,MACR,OAAQ,YAAY,QAAQ,GAAI,CAAA,CACnC,EACDT,EAAoBkB,EAAa,EAAE,CACvC,OAASrB,EAAO,CACZ,QAAQ,KAAK,qCAAsCA,CAAK,EACxDG,EAAoB,EAAK,CAC7B,CACJ,EAAG,CAAA,CAAE,EAELnF,EAAU,IAAM,CACZoG,EAAA,CACJ,EAAG,CAACA,CAAwB,CAAC,EAE7BpG,EAAU,IAAM,EACc,SAAY,CAClCuE,EAAW,EAAI,EACfU,EAAS,IAAI,EAEb,GAAI,CACA,MAAMqB,EAAe,MAAMd,EAAA,EAE3B,GAAIc,EAAc,CAEd,MAAMC,EAAoBC,GAAUA,EAAM,OAAOnH,GAAQA,EAAK,WAAW,EAEzEoF,EAAY8B,EAAiBD,EAAa,UAAY,CAAA,CAAE,EAAE,MAAM,EAAG,EAAE,CAAC,EACtE3B,EAAY4B,EAAiBD,EAAa,UAAY,CAAA,CAAE,CAAC,EAGzD,MAAMG,EAAWF,EAAiBD,EAAa,UAAY,CAAA,CAAE,EAGvDI,EAAe,CAAC,GAAGD,CAAQ,EAAE,KAAK,CAACE,EAAGC,KAAOA,EAAE,YAAc,IAAMD,EAAE,YAAc,EAAE,EAC3F9B,EAAW6B,EAAa,MAAM,EAAG,EAAE,CAAC,EAGpC,MAAMG,EAAgB,CAAC,GAAGJ,CAAQ,EAAE,KAAK,CAACE,EAAGC,KAAOA,EAAE,cAAgB,IAAMD,EAAE,cAAgB,EAAE,EAChG5B,EAAY8B,EAAc,MAAM,EAAG,EAAE,CAAC,CAC1C,KACI,OAAM,IAAI,MAAM,iCAAiC,CAGzD,OAAS7B,EAAO,CACZ,QAAQ,MAAM,6BAA8BA,CAAK,EACjDC,EAAS,qDAAqD,CAClE,QAAA,CACIV,EAAW,EAAK,CACpB,CACJ,GAEA,CACJ,EAAG,CAACiB,CAAsB,CAAC,EAE3B,MAAMsB,EAAgB,CAAC1G,EAAOoG,IACtB,CAACA,GAASA,EAAM,SAAW,EACpB,KAIP9C,EAAC,UAAA,CAAQ,MAAM,eACX,SAAA,CAAAP,EAAC,MAAI,SAAA/C,CAAA,CAAM,IACV,MAAA,CAAI,MAAM,gBACN,SAAAoG,EAAM,IAAInH,GACP8D,EAAC/D,EAAA,CAEG,KAAAC,EACA,QAAS,IAAMyG,EAAiBzG,CAAI,CAAA,EAF/B,GAAGe,CAAK,IAAIf,EAAK,EAAE,EAAA,CAI/B,CAAA,CACL,CAAA,EACJ,EAIF0H,EAAyB,IAC3B5D,EAAC,MAAA,CAAI,MAAM,iBACP,SAAAO,EAAC,MAAA,CAAI,MAAO,oBAAoBwB,EAAmB,SAAW,SAAS,GACnE,SAAA,CAAA/B,EAAC,OAAA,CAAK,MAAM,YAAA,CAAa,EAAO,YACtB+B,EAAmB,SAAW,SAAA,CAAA,CAC5C,CAAA,CACJ,EAGE8B,EAAe,CAAC,CAAE,MAAAhC,EAAO,QAAAiC,KAC3BvD,EAAC,MAAA,CAAI,MAAM,kBACP,SAAA,CAAAA,EAAC,MAAA,CAAI,MAAM,gBACP,SAAA,CAAAP,EAAC,MAAG,SAAA,sBAAA,CAAoB,EACxBA,EAAC,IAAA,CAAG,SAAA6B,CAAAA,CAAM,IACT,SAAA,CAAO,QAASiC,EAAS,MAAM,eAAe,SAAA,WAAA,CAAS,CAAA,EAC5D,IACCF,EAAA,CAAA,CAAuB,CAAA,EAC5B,EAGJ,OAAIzC,EAEIZ,EAAC,MAAA,CAAI,MAAM,iCACP,SAAA,CAAAP,EAAC,KAAA,CAAG,MAAM,aAAa,SAAA,QAAK,IAC3B4D,EAAA,EAAuB,EACxB5D,EAAC+D,GAAA,CAAe,KAAM,kBAAA,CAAoB,CAAA,EAC9C,EAIJlC,EAEItB,EAAC,MAAA,CAAI,MAAM,iCACP,SAAA,CAAAP,EAAC,KAAA,CAAG,MAAM,aAAa,SAAA,QAAK,EAC5BA,EAAC6D,EAAA,CACG,MAAAhC,EACA,QAAS,IAAM,CACXC,EAAS,IAAI,EACbmB,EAAA,CAEJ,CAAA,CAAA,CACJ,EACJ,EAKJ1C,EAAC,MAAA,CAAI,MAAM,iCACP,SAAA,CAAAP,EAAC,KAAA,CAAG,MAAM,aAAa,SAAA,QAAK,IAE3B,MAAA,CAAI,MAAM,iBACP,SAAAA,EAAC4D,IAAuB,EAC5B,EAECxB,EAAkB,OAAS,GACxB7B,EAAC,UAAA,CAAQ,MAAM,eACX,SAAA,CAAAP,EAAC,MAAG,SAAA,mBAAA,CAAiB,IACpB,MAAA,CAAI,MAAM,uCACN,SAAAoC,EAAkB,IAAIlG,GACnB8D,EAAC/D,EAAA,CAEG,KAAAC,EACA,SAAUA,EAAK,iBACf,SAAUA,EAAK,iBACf,QAAS,IAAMyG,EAAiBzG,CAAI,CAAA,EAJ/B,qBAAqBA,EAAK,EAAE,EAAA,CAMxC,CAAA,CACL,CAAA,EACJ,EAGHyH,EAAc,eAAgBtC,CAAQ,EACtCsC,EAAc,cAAepC,CAAQ,EACrCoC,EAAc,gBAAiBlC,CAAO,EACtCkC,EAAc,kBAAmBhC,CAAQ,EAEzC,CAACR,GACDE,EAAS,SAAW,GACpBI,EAAQ,SAAW,GACnBE,EAAS,SAAW,GACjBpB,EAAC,MAAA,CAAI,MAAM,aACP,SAAA,CAAAP,EAAC,MAAG,SAAA,4BAAA,CAA0B,EAC9BA,EAAC,KAAE,SAAA,6CAAA,CAA2C,CAAA,CAAA,CAClD,CAAA,EAER,CAER"}